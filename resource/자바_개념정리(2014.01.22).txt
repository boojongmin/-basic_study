 
만나서 반갑습니다. 좋은 인연되기를 기원하며...
================================
 담당강사 : 박 인 상
 010 - 6865 - 5900
 park5901@hanmail.net  
-----------------------------------------------------
    먼저
    D:\ 밑에 여러분 폴더 생성(이니셜) 영문으로
----------------------------------------------------   
    <강의자료에 필요한 자료 다운받기>
       => http://blog.naver.com/king5901
         
         => 자바 강의자료 카테고리쪽에
             => "자바 클래스 정리" 클릭 후 첨부파일(pdf) 파일을 여러분 폴더에 
                   붙여넣기 => 띄우기
-------------------------------------------------------------------------






이클립스 실행 후
[New] 메뉴 
    - Switch Workspace
          ▶ Other
                  Workspace란: 여러분폴더\workspace 













 프로그램 작성 목적? => 자료처리 즉 정보처리







    <JDK API 문서 참조하기>
     http://docs.oracle.com/javase/7/docs/api/  접속













    <한글판 JDK API 문서 참조>
     http://docs.xrath.com/java/se/6/docs/ko/api/index.html


   <JDK 다운로드>
    http://www.oracle.com/technetwork/java/javase/downloads/index.html



   <이클립스 다운로드>
     http://www.eclipse.org/downloads/





  ※ JDK 1.7 설치하기전에 먼저 여러분의 시스템 
     운영체제가 32Bit 또는 64Bit 인지 체크한다
     → 바탕화면 - 내컴퓨터 - 오,마 클릭 하여 확인
--------------------------------------------------------
   <실습환경>
   1. JDK 1.7 설치
   2. eclipse 압축파일 풀기
-------------------------------------













    eclipse helios나 juno-win32.zip 압축파일을 여러분 폴더에 붙여넣기한다




    JDK 1.7 설치경로
    C:\java\jdk1.7

     여러분폴더\workspace
-------------------------------------
※ 이클립스 실행 시 다음과 같은 메시지가 나오면

   Failed to create the Java Virtual Machine.
   => 해결방법
    해당 eclipse 폴더에 => eclipse.ini 구성 파일에 다음을 추가한다.
    ▶ 보통 이클립스를 구동하는데에는 javaw.exe을 사용한다.
--------------------------------------
openFile 밑에
-vm
C:\Java\jdk1.7\bin\javaw.exe
--------------------------------------

   자바 프로그램의 실행 class 안에는 main() 메소드가
   있어야 한다.
   
     public static void main(String args[])
 
       => 시작 - 실행 - \\211.48.40.101

       c:\park\OracleIns 폴더 공유 =>  2개 파일을 내려받아
                                             => 여러분 폴더에 붙여넣기
                                 그리고   => c:\다운로드 폴더에도 
                                                  붙여넣기 한다.







        반드시 =>  "여기에 압축풀기"  => eclipse 폴더 생성


    <이클립스 다운로드>
     http://www.eclipse.org/downloads/











  
<프로젝트1>
  프로젝트이름 : 헬로월드 출력
  클래스이름    : HelloWorld
-----------------------------------













자바의 main() 메소드
public static void main(String args[])

  => 이렇게 코딩해야 하는 이유
       public - 다른 클래스에서 mian 메소드 접근 허용을 의해서
       static  - 객체 생성전부터 호출이 가능하게 하기 위해서
       void  - main() 메소드 실행 후 리턴값이 없다(void: 무형)
       String args[] - 자바는 명령행에 주어진 모든 인자를 문자열로 처리하여
                          main( ) 메소드에 전달한다 
-----------------------------------------------------------------------------------










System 클래스의 
   => Field   out : 표준 출력장치(즉 모니터(콘솔창)) => System.out
                 in   : 표준 입력장치(즉 키보드)           => System.in








1. 자바에 기본문법=> 자료형, 연산자의 종류와 우선순위, 제어문

2. 자료구조 => 배열(Array)
                      - 고정 배열
                      - 가변 배열=> Vector 나 ArrayList 클래스에 의해 생성된 객체
3. 알고리즘 터득
    - 정렬(sort) 알고리즘
    - 검색(search) 알고리즘













프로그램 작성 이유? => 자료처리, 즉 정보처리

          처리하고자 하는 자료를 어디에 저장할꺼나? => 배열 이라는 자료구조
              때로는 정렬, 검색을 하자

      byte  a;
           a라는 변수는 메모리에 1byte를 차지하게 된다.
           2
           정수에 표현범위  => -128 ~ 127

      byte  a=10;   //초기값 설정

   short  b;
           b라는 변수는 메모리에 2byte를 차지하게 된다.
           정수에 표현범위  => -32768 ~ 32767








public static void main(String args[])



* 변수 => 데이터를 저장하는 공간

      자료형  변수  = 초기값;
       int       a     =  10;

   (1) 지역변수=> 어떤 메소드 안에서 선언한 변수=> 자동초기화(x)
   (2) 전역변수=> 어떤 메소드 밖에서 선언한 변수=> 자동초기화(o)


* 리터럴(literal) 이란?
   : 프로그램에서 직접적으로 표현되는 상수값
     <종류>
      정수형 리터럴, 실수형 리터럴, 문자형 리터럴,
      논리형 리터럴, 문자열 리터럴, 특수문자 리터럴,
      null 리터럴 

    (예) int a = 300;
          float b = 65.45;
          boolean c = true;
          String str = "박태호";






* 상수 => 변수와 달리 프로그램 실행 중에 값이 바뀔 수 없다
               상수는 반드시 초기값을 주어야 한다.

              (예) final        int        PRICE    =   10;
                   상수선언   자료형   상수이름    초기화
--------------------------------------------------------------
 















------------------------------------------------------------------------
<프로젝트2>
프로젝트이름: main 메소드에 인자값 전달
클래스이름: MainArgs
-------------------------






























  





<프로젝트3>
프로젝트이름: Data 형변환 실습1
클래스이름   : Test1
-------------------------------------
* JAVA 언어의 형변환 => "정수형" 데이터인 경우
===============================
  (1) 자동 형변환
       => 크기가 작은 자료형의 값을 큰 자료형의 변수에 저장할 때

  (2) 명시적 형변환(프로그래머가 해준다)
       => 큰 자료형의 값을 작은 자료형의 변수에 저장 할 때
            int(4byte) 에서 => short(2byte) 로 변환시
   [참고]
   중요 => 이항 연산자(* , /, %, +, -)는 연산을 수행하기 전에
               - 크기가 4byte 이하인 자료형(즉 byte, short형)을 
                 int형(4byte)으로 변환한다 => 자동 형변환
               - 양쪽 피연산자의 타입을 일치시킨다


















<프로젝트4>
프로젝트이름: Data 형변환 실습2
클래스이름   : Test2
------------------------------------

(예)   a=10;
        b=20;
        c= 30;
        d = a*b+c;  




[숙제]
 달력 프로그램 작성시 
 윤년(2월이 29일)의 조건
   => 년도를 4로 나눈 나머지가 0 이고
                  100으로 나눈 나머지가 0 이아니어야 한다
         다만(이거나 의미) 400으로 나눈 나머지가 0인 경우

   <프로그램 코딩> => &&(AND 연산자), || (OR 연산자) 연산자를 활용하여
      int year;   //해당 년도 변수
      int leap_year:         //29가 저장될 변수
      int common_year;  //28이 저장될 변수

      if(year%4 == 0 && year%100 != 0) || (year%400 == 0)
             leap_year = 29;   //윤년
      else 
             common_year = 28;  //평년
-----------------------------------------------------------------


      
   






















<프로젝트5>
프로젝트이름 : 문자형 데이터타입 실습
클래스이름    : CharTest
----------------------------
[실행결과]
ABC ....................Z
abc  ....................z
------------------------

 ++x  → 선처리(prefix)  
 x++  → 후처리(postfix)
 







[참고]
- 유니코드는 세계 각국의 언어를 통일된 방법으로 표현할 수 있게 제안된
  국제적인 코드 규약이다

<유니코드(Unicode) 값>
================
    '0'  =>  48
    'A'  => 65
    'a'  =>  97
--------------------------






<차이점> 1증가 연산자 ++
------------------           --------------------   
 선처리(prefix)              후처리(postfix)
------------------           -------------------
 short a = 10;               short a = 10;
 short b = ++a;            short b = a++;
--------------------        ----------------------
       a => 11 기억         a => 11 기억
       b => 11 기억         b => 10 기억 
------------------------------------------------






<프로젝트6>
프로젝트이름 : 자료형 테스트
클래스이름:     DataTypeTest
----------------------------------

<프로젝트7>
프로젝트이름 : 전역변수 자료형 테스트
클래스이름:     GVTest
----------------------------------











프로젝트이름 : 메인메소드에게 인자값 전달하기
클래스이름    : ArgTest
-------------------------------------------------------
[참고]
java.lang 패키지의 
  => Integer 클래스의 중요 메소드

     ▶ static int parseInt(String s) => "문자열객체" -> 정수로 변환해주는 메소드
          기능: Parses the string argument as a signed decimal integer
         => static 메소드이기 때문에 클래스이름으로 바로 접근 가능하다

      ▶ static String toString(int i) => 정수  -> "문자열객체"로 변환해주는 메소드
          기능: Returns a String object representing the specified integer
------------------------------------------------------------------------------------------------








<프로젝트8>
프로젝트이름 : switch문 실습
클래스이름    : SwitchTest
----------------------------------
[실행결과]
문자 한 개를 입력하세요. >> A
America

문자 한 개를 입력하세요. >> a
America

문자 한 개를 입력하세요. >> K
Korea

문자 한 개를 입력하세요. >> k
Korea
-------------------------------------------
static InputStream in 
The "standard" input stream.
 
static PrintStream out 
The "standard" output stream. 

public static final PrintStream out

The "standard" output stream. This stream is already open and ready 
to accept output data. Typically this stream corresponds to display 
output or another output destination specified by the host environment or user. 
For simple stand-alone Java applications, a typical way to write a line of output 
data is: 

     System.out.println(data)
--------------------------------------------
※ 모니터로 출력하는 방법

System 클래스의 out 필드는 표준 출력을 하는데 사용되는 필드이다.

static PrintStream out 
The "standard" output stream.

이 필드는 System 클래스에 PrintStream 클래스 타입으로 선언되어 있다. 
그렇기 때문에 PrintStream 클래스의 println, print, printf 메소드를 사용할 수 
있는 것이다.

(예) System.out.println("Korea");

 java.io 패키지의
   => PrintStream 클래스
         => println(), print(), printf() 메소드 
                 → [주의] ※ 이 메소드들은 System 클래스의 메소드가 아님
------------------------------------------------------------------------------















■ 제어문




■ 배열(Array)이란? 
===========
배열은 인덱스와 인덱스에 대응하는 데이터들로 이루어진 자료 구조로서 
배열에는 같은 종류의 데이터들이 순차적으로 저장된다. 
















같은 타입의 여러 변수를 하나의 묶음으로 다루는 개념 

[배열 선언 및 생성]
자바에서 배열을 생성할땐, 두 단계가 필요하다. 
(1) 배열에 대한 레퍼런스 변수 선언 

이는 두가지 방법이 있으며, 둘다 똑같은 작용을 한다. 

 ▶ 배열타입  배열에대한레퍼런스변수  배열선언 혹은
 ▶ 배열타입  배열선언  배열에대한레퍼런스변수 

  예: int intArr[ ]; 혹은 int[ ] intArr;  

(2) 배열 생성
    이 과정은 배열 공간을 할당받는 과정이다. 
    new 연산자를 이용하며 [ ] 안에 배열의 원소개수를 적는다. 

    예:  int  intArr[ ] = new  int [10]; 
    => 위 소스는 10개의 정수형 공간을 할당받아 배열을 생성하고, 
         생성된 배열에 대한 주소값을 intArr에 저장한다. 
  ※ 주의 
    ▶ 배열에 대한 레퍼런스 변수를 선언할 때 [] 안에 배열의 크기를 
        주면 에러가 발생한다. 

        틀린 예: int intArr[10];  

  (3) 배열의 선언과 동시에 생성

      int intArr[] = new int[10]; 
      String strArr[] = new String[10];
      float floatArr[] = new float[5]; 

    (4) 배열 초기화

       int intArr[] = {1,2,3,4}; 

    (5) 배열의 크기와 인덱스
         배열의 인덱스는 정수만 가능하며, 정수형 상수도 사용할 수 있다. 
         인덱스는 0 부터 시작하며, 마지막 원소의 인덱스는 (배열 크기 ? 1) 이 됩니다. 

         int intArr [] = new int[10]; // 인덱스 0~9 

    (6) 배열의 크기, length 필드
         자바에서는 배열도 하나의 객체처럼 다루어진다.
         배열의 크기는 new 문장에서 결정되며, 생성된 배열 객체 내에 저장된다.
         배열의 크기는 배열 객체의 length 필드에 저장되어 있다.
         프로그램에서 배열의 크기를 사용할때, length 필드를 이용하면 
         프로그램의 유연성이 높아진다. 


<일반 for문>
[형식]
for(초기값; 조건; 증가)
{
      반복문장들
          .......
          .......
}
-------------------------------------------------






※ 중요
<확장 for문> => 자바스크립트의 for in 반복문과 같은 개념
[형식]
   for (자료형 변수명  :  배열명 or 객체인스턴스변수명)
   {
          반복문장들
          .......
          .......
   } 
----------------------------------------------------------------------------
[참고]
객체인스턴스변수명 이란?
       => Vector나 ArrayList 클래스에 의해 가변배열 객체가 생성되면 
            그 객체를 가리키는 객체인스턴스 변수를 말한다

자바스크립트의 for in 반복문과 같은 개념
   for (var i in array)
   {

   }
--------------------------------------------------------------------











<프로젝트9> 중요
프로젝트이름 : 확장 for문 실습
클래스이름    : ExtForTest
----------------------------------
<일반 for문>
for(초기값; 조건; 증가)
{
      반복문장들
          .......
          .......
}
-------------------------------------
<확장 for문>
   for (자료형 변수명  :  배열명)
   {
          반복문장들
          .......
          .......
   } 
------------------------------------------














자료구조의 가장 대표적인 것 => 배열(Array)

  배열 => 자료형  변수[ ];  
           (예) int    a[ ] = {10,20,30,40,50};    //1차원 배열의 초기화
 ------------------------------------------------------------------------------






프로젝트이름 : 실습1
클래스이름    : CaseChanger
---------------------------------














프로젝트이름 : 실습2
클래스이름    : ChangeMoney
-----------------------------------
java.util 패키지의 Scanner 클래스의 메소드
    => int nextInt()
         기능: Scans the next token of the input as an int. 















프로젝트이름 : 실습3
클래스이름    : LeapYear
---------------------------------
















-------------------------------------------
<정렬(sort) 알고리즘의 종류>= "자료구조" 과목

  1. 삽입(Insertion) 정렬
  2. 버블(Bubble) 정렬 => 개선된 버블 정렬
  3. 선택(selection) 정렬 => 프로그램 구현이 쉽다 
  4. 퀵(Quick) 정렬
-------------------------------------------------------













-----------------------------------
<프로젝트10>  중요
프로젝트이름 : 선택정렬(숫자인 경우)
클래스이름    : SelectionNum
------------------------------------------

<프로젝트11>  중요
프로젝트이름 : 선택정렬(문자열인 경우)
클래스이름    : StringSelection
------------------------------------------
[참고]
java.lang 패키지의 
  => String 클래스
         int compareTo(String anotherString)   
         기능: Compares two strings lexicographically.
                 두개의 문자열을 사전식으로 비교하는 메소드
  (예) a라는 문자열(String)과 b라는 문자열(String)을 비교하여
              a.compareTo(b)

              a       >        b     =>  양수 리턴
              a    같으면    b      =>  0  리턴
              a      <         b     =>  음수  리턴 
-------------------------------------------------------------



java.lang 패키지의 String 클래스의 메소드

   => int compareTo(String anotherString)
        기능: Compares two strings lexicographically.
                두 개의 문자열을 사전 순서를 기반으로 비교하는 메소드

        (예) a라는 문자열(String)과 b라는 문자열(String)을 비교하여
              a.compareTo(b)

              a       >        b     =>  양수 리턴
              a    같으면    b      =>  0  리턴
              a      <         b     =>  음수  리턴  
----------------------------------------------------------




<프로젝트12> =>  매우 중요
프로젝트이름 : 2차원 배열 정렬
클래스이름    : TwoDSelectionString
--------------------------------------------
2차원 배열 속에 다음과 같이 데이터가 초기화 되어 있다

                      번호   이름     출신도   직업
String str[][] = {{"10","박태호","서울","회사원"},
                      {"2","김의실","경남","공무원"},
                      {"3","오수철","부산","연예인"}};
   ▶ 정렬 후 
       [프로그램 실행결과] => "이름" 정렬인 경우(2차원 배열에서)
       ---------------------------
        2   김의실 경남 회사원
        10 박태호 서울 공무원
        3   오수철 부산 연예인
       ---------------------------

        "2"  => 2
---------------------------------------------------------------
 ※ Wrapper 클래스 중 하나인  Integer 클래스 => "객체"를 다루기 위한 클래스 
                                                 => 자바는 객체지향 언어이기 때문에

    int parseInt(String s)
        기능: Parses the string argument as a signed decimal integer.
         (예) parseInt("5") => 5

    String toString(int i)
       기능: Returns a String object representing the specified integer.
         (예) toString(5) = "5" 
---------------------------------------------------------------------------
[참고]
자바의 배열에서 배열의 크기(개수)를 쉽게 구하는 방법
  => 배열명.length  





Wrapper 클래스의 Integer 클래스

[중요]
   어떤 클래스의 메소드 앞에 static이 붙어 있으면 클래스이름으로 바로 호출 가능

                          => Integer.toString(정수)  => 스크링 객체 로 결과를 리턴
                               Integer.parseInt(스크링객체) => 정수로 결과를 리턴






<숙제>
  자바에 Wrapper 클래스란?  








<프로젝트13>
프로젝트이름 : 버블정렬 알고리즘
클래스이름    : BubbleSort
-------------------------------------

■ 실행속도를 좀 더 빠르게... => 중요
<프로젝트14>
프로젝트이름 : 개선된 버블정렬 
클래스이름    : ImproveBubbleSort
------------------------------------------






※ 매우 중요
<정렬 알고리즘 종류>
================
1. 선택 정렬
2. 버블 정렬 => 개선된 버블 정렬
----------------------------------------







<검색(Search) 알고리즘 종류>
====================
1. 순차 검색(Sequential Search)
2. 이분 검색(Binary Search)
-------------------------------------
<차이점>
-------------------                        ------------------
   순차검색                                   이분검색
-------------------                        ------------------
장점:                                           장점:
    - 프로그램 구현이 쉽다                    - 평균검색회수 = log₂N
    - 자료를 정렬(sort)시키지                     (단 N은 데이터 개수)
      않아도 검색이 가능하다                 - 최대비교회수 = (log₂N)+1
단점:                                           단점:
    - 평균검색회수 = (N+1)/2                - 반드시 자료를 정렬(sort)시켜야                     
               (단 N은 데이터 개수)              검색이 가능하다
                                                     - 프로그램 구현이 순차검색 보다
                                                       좀 더 복잡하다
----------------------------------          ---------------------------------------- 
                      














<프로젝트 15> => 중요
프로젝트이름 : 순차검색(숫자인 경우)
클래스이름    : SequentialSearch
-----------------------------------------
[참고]
* 자바에서 => 키보드로 부터 데이터를 입력받기 위해서는
  java.util 패키지의
    => Scanner 클래스 사용한다
    [생성자]
       => Scanner(InputStream source)
    [메소드]
       => int  nextInt()  => 입력된 문자열 값을 int형으로 가져오는 메소드(숫자 검색시 사용)
       => String  next()  => "문자열"을 "문자열"로 변환(문자열 검색시 사용)
--------------------------------------------------------------------------------------


















Wrapper 클래스 중의 하나 => Integer 클래스

※ Wrapper 클래스란?
    => 기본 데이터를 "객체"로 포장하여 객체화 시키는 개념
         자바는 객체 지향 언어이기 때문에 가변배열 같은 경우 
         객체만 저장할 수 있기 때문이다.

  8개를 총칭=>  1. Byte 클래스
                      2. Short
                      3. Integer
                      4. Long
                      5. Float
                      6. Double
                      7. Character
                      8. Boolean
--------------------------------------------------------------------------
Java의 경우 전역 변수의 경우 자동으로 초기화를 시켜준다.
 - int의 경우 0
 - String의 경우 Null
 - double의 경우 0.0
 - boolean 의 경우 false

또한 지역변수의 경우는 초기화하지 않고 사용할 경우 컴파일 단계에서 
체크해준다. 
------------------------------------------------------------------------------
프로그래밍에서 자주 변하지 않는 일정한 값이나 설정 정보 같은 공용자원에 
대한 접근에 있어서 매번 메모리에 로딩하거나 값을 읽어들이는 것보다 
일종의 '전역변수'와 같은 개념을 통해 접근하는 것이 비용도 줄이고, 효율도 
높일 수 있다. 
자바에는 이런 전역변수 형태의 접근을 가능하게 만들어 주는 static(정적) 
이라는 키워드가 있다.

클래스의 변수나 메소드를 static으로 선언하면 그 변수는 객체의 변수가 아니라 클래스 변수가 된다. 
클래스 변수이므로 어떠한 객체라도 동일한 주소로 참조하게 된다.
일반적으로 클래스의 변수나 메소드는 해당 클래스가 인스턴스화 되기 전에는 사용할 수 없는데, 
static 으로 선언된 변수나 메소드는 해당 클래스의 인스턴스 여부와 상관없이 바로 접근이 가능하고, 사용이 가능하다.
------------------------------------------------------------


<프로젝트 16>
프로젝트이름 : 순차검색(문자열)
클래스이름    : SequenString
------------------------------------ 
java.lang 패키지의
    => String 클래스
         [필요 메소드]
              boolean equals(Object anObject)

              (예) a. equals(b)
               => a라는 문자열과 b라는 문자열을 비교하여
                    같으면 true를 리턴하고 다르면 false를 리턴한다
-------------------------------------------------------------------










<프로젝트 17> => 매우 중요
프로젝트이름 : 2차원 배열 순차검색(문자열)
클래스이름    : TwoDSequenString
------------------------------------------------- 
 <초기 데이터>
  String str[][] = {{"1","오수철","남자"},
                         {"2","김연아","여자"},
                         {"3","박태호","남자"},
                         {"4","이외수","남자"}};

   위 데이터를 활용하여 프로그램 작성하시오.
   (단, "이름" 으로 검색한다.)














[과제]
1. 2차 배열 순차검색 알고리즘 적용하여 => 해결(오후 과제)
2. 이분검색(숫자)
2. 이분검색(문자열)
-----------------------------------------------------------



















java.lang 패키지의 String 클래스의
  [중요 메소드]
 
   int compareTo(String anotherString)

   boolean equals(Object anObject)
----------------------------------------------






















<프로젝트 18>
프로젝트이름 : 이분검색 알고리즘(숫자인 경우)
클래스이름    : BinarySearch
------------------------------------------------------
[숙제] 분석하시오
  찾고자 하는 값이 90을 요구했다
     low   >    high
      8            7

 찾고자 하는 값이 1을 요구했다
     low   >    high
      0            -1

 찾고자 하는 값이 36을 요구했다
     low   >    high
      4            3
--------------------------------------



















<프로젝트 19>
프로젝트이름 : 이분검색(문자열) 알고리즘
클래스이름    : BinaryStringSearch
------------------------------------------------

[과제] 힌트
  아스키(ASC) 코드값
==============
  'A'  => 65     'B' => 66
  'a'  => 97     'b'  => 98 
  '0'  => 48     '1' => 49
------------------------------
  
  while(true){

       반복분장들
        . . . . . . . 
        . . . . . . .
  }


    *=

   int a =3;
   int b = 5;
   a = a * b;
   a *= b;

   +=

      항1
    조건식 ?   항2  :   항3












   API 문서 레퍼런스 하기=> 생성자와 메소드 체크
=================================
   1. Vector 클래스  => 이 클래스의 생성자에 의해 생성된 객체 => 가변배열
   2. ArrayList 클래스 => 이 클래스의 생성자에 의해 생성된 객체 => 가변배열
   3. StringTokenizer 클래스
   4. HashTable 클래스
-------------------------------------------------------------------------------------------
    




























* 배열
=====
[고정 배열] => 정수, 객체 저장 가능
[가변 배열] => Vector, ArrayList 클래스에서 생성된 => 객체 => 가변 배열이라함
                => 가변 배열에는 "객체"만 저장할 수 있다
                => Wapper 클래스를 통해서 기본 데이터를 => "객체"로 포장하여 저장













--------------------------------------
<프로젝트 20> => 매우 중요=> "고객관리 시스템" 프로젝트에서 활용한다
프로젝트이름 : Vector 클래스 다루기
클래스이름    : VectorTest
---------------------------------------
[참고]
Vector 클래스의
   생성자
            Vector(int initialCapacity, int capacityIncrement)

    제네릭(generic) 개념
     <E>


















java.util 패키지의
  =>Vector 클래스의 
     <생성자>
        => Vector(int initialCapacity, int capacityIncrement)
             (예) new Vector(4,3)








     //Vector 클래스 객체 생성 공식
     --------------------------------------------------------------------------
      Vector<객체타입> 인스턴스변수 = new Vector<객체타입>( );   => 기본 10개 확보
     --------------------------------------------------------------------------

      ※ Vector 클래스의 메소드 호출 공식
      ---------------------------------------
          인스턴스변수.메소드( ) 호출   => "객체"가 어떤 행위를 해라
     ---------------------------------------













     <주요 메소드>
      size()                  => Returns the number of components in this vector
      int capacity()        => Returns the current capacity of this vector.
      ------------------- 
      add(E e)             => Appends the specified element to the end of this Vector.
      get(int index)      => Returns the element at the specified position in this Vector.
      remove(int index) =>Removes the element at the specified position in this Vector.
      ---------------------------
      addElement(E obj)     => Adds the specified component to the end of this vector, 
                                        increasing its size by one.
      elementAt(int index)  => Returns the component at the specified index.
      removeElementAt(int index) => Deletes the component at the specified index. 
---------------------------------------------------------------------------------------------------








<프로젝트 21> => 중요
프로젝트이름 : ArrayList 클래스 다루기
클래스이름    : ArrayListTest
--------------------------------------------

 자동박싱(boxing) => JDK 1.5부터 추가된 기능

 ★ 프로그래머가 메소드 만드는 방법












[과제]
객체 출력시 => 반복 출력 => 메소드(사용자 정의 메소드) 구현 
                                  => 필요할때 마다 호출하여 출력할 수 있도록 소스 변경 

  StringTokenizer 클래스
  HashTable 클래스
     => 2개 클래스 API 문서 참조하기
-------------------------------------------------------------------------











● 멤버  - 필드
              메소드()

★ <차이점>
---------------------                                        ------------------
   non-static 멤버                                           static 멤버
---------------------                                        ------------------
 - 인스턴스 멤버라고도함                                 - 클래스 멤버라함
 - "객체"가 생길 때 객체 내부에                         - "객체"를 생성하지 않고도 
   하나씩 생성                                                   사용가능
 - 객체마다 자신의 고유한 멤버                          - 클래스당 하나만 생성
   공간을 가지며 객체들이                                - 동일한 클래스의 모든 객체들에
   공유하지 않는다                                           의해 공유됨 
 - 객체가 사라지면 non-static 멤버도
   함께 사라진다 
----------------------------------------                    --------------------------------------
(사용 예)
 클래스이름 인스턴스변수 = new 클래스생성자( ); ㅣ  클래스이름.메소드( ) 호출
 인스턴스변수.메소드( ) 호출                            ㅣ
---------------------------------------------------------------------------------------------












* ArrayList 클래스의
   <생성자>
    ArrayList()
      =>Constructs an empty list with an initial capacity of ten.

   <중요 메소드>
    boolean  add(E e)                          -> 마지막에 객체 추가
    void       add(int index, E element)    -> 중간에 객체 추가
    E            set(int index, E element)    -> 객체 변경
    E            remove(int index)             -> 객체 삭제
    boolean  remove(Object o)              -> 객체 삭제
    E            get(int index)                  -> 객체 얻어올 때

  * Collections 클래스의
      메소드
          => static void sort(List list)    -> 객체 정렬시키는 메소드
---------------------------------------------------------------------------
 ※ 메소드 오버로딩 => 같은 이름의 메소드가 여러개 있다

 ※ 어떤 메소드 앞에 static이 붙어 있으면 => 클래스이름으로 호출가능
    (예) Collections.sort(list);






<프로젝트 22>
프로젝트이름 : StringTokenizer 클래스 다루기
클래스이름    : StringTokenizerTest
-----------------------------------------------------
java.util 패키지의
 => StringTokenizer 클래스
  <생성자> => 3개
     StringTokenizer(String str, String delim)
     (예)
     String str = "Name=홍길동/Addr=서울강남구/Age=26";
     StringTokenizer st = new StringTokenizer(str, "/");  

    [토큰 3개]
     Name=홍길동  
     Addr=서울강남구
     Age=26









  <메소드>
       int countTokens()
       boolean hasMoreTokens() 
           => 스트링토큰아이저에 다음 토큰이 있으면 true 리턴
       String nextToken()
           => 다음 토큰 리턴







-----------------------------------------------------------------------
(응용 예)
      String str = "김진명, 최인호, 조정래, 박경리, 정비석";

      StringTokenizer st = new StringTokenizer(str, ", ");  
--------------------------------------------------------------------




<프로젝트 23>
프로젝트이름 : Hashtable 클래스 다루기
클래스이름    : HashName
--------------------------------------------

















java.util 패키지의
  => Hashtable 클래스
        <생성자>
            => Hashtable(int initialCapacity)
       <중요 메소드>
            => put(K key, V value)
            => get(Object key)
----------------------------------------------













while(true){   //무한 루프(loop)
    
      어떤 조건일 때 빠져나가는 처리를 해주어야 한다			
}
---------------------------------------------------------
for( ;  ; ){       //무한 루프(loop)

     어떤 조건일 때 빠져나가는 처리를 해주어야 한다
}
-----------------------------------------------------------


    int i;
    int sum = 0;   //지역변수

    for(i=1; i<=100; i++){
          sum = sum + i;

----------------------------------------------------------






<프로젝트 24>
프로젝트이름 : StringBuffer 클래스 다루기
클래스이름    : StringBufferTest
---------------------------------------------
[참고] 차이점
  ■ String 클래스
     - String 객체가 한번 만들어진 문자열은 수정 할 수 없다
     - '간단한' 문자열을 처리하고자 하는 경우 적합하다 

  ■ StringBuffer 클래스
     - StringBuffer 객체는 내부에 문자열을 저장하는 가변 크기의 
       버퍼를 가지고 있기 때문에 생성 후 문자열을 바꿀 수 있다
       따라서 문자의 개수가 늘어나면 내부 버퍼 크기는 문자열 길이에 따라
       가변적으로 변한다
     - 문자열의 길이가 길거나 문자열 작업이 많은 경우 적합하다
-------------------------------------------------------------------------------
<생성자>
      StringBuffer(int capacity)
















<프로그래밍 발전 과정>
 * 절차 지향(POP) => 객체 지향(OOP) => 관점 지향(AOP) 프로그래밍 방식      
                                                      (Spring 프레임워크 쪽에서 다루고 있음)


















 
소프트웨어 공학 => "재사용" 








  자식클래스  extends   부모클래스













<프로젝트 25> => 이 프로젝트를 통하여 "객체지향" 개념 터득 => 중요
프로젝트이름 :  Car 클래스 구현
클래스이름    :  Car
-----------------------------------











[과제]
(1) 클래스 상속 => 정리
(2) 인터페이스 개념 => 정리
-----------------------------------














<프로젝트 26> =>'상속성'과 '다형성' 개념을 터득하는 프로젝트
프로젝트이름 :  Car 클래스 상속 구현
패키지이름    :  CarTest 
클래스이름    :  Car
클래스이름    :  Truck
-------------------------------------
 부모(상위) 클래스 => Car
 자식(하위) 클래스 => Truck 
 <상속 시키는 방법>
     자식클래스이름  extends  부모클래스이름

     (예)                       키워드
      public class Truck  extends  Car {

      }
--------------------------------------------------







<차이점>
전역변수 => 생성자나 메소드 밖에서 선언한 변수, 자동 초기화가 된다
지역변수 => 메소드 블록안에서 선언한 변수, 자동 초기화가 안된다
----------------------------------------------------------------------------













<프로젝트 27>
프로젝트이름 :  인터페이스 설계
클래스이름    :  InterfaceTest
------------------------------------


<프로젝트 28> => 윈도우 프로그램 작성
프로젝트이름 : 마우스이벤트 처리
클래스이름:     ListenerMouseEx
--------------------------------------------


<프로젝트 29> => 코드(Code) 처리 => 매우 중요
프로젝트이름 : 주민번호 정보추출
클래스이름    : JuminCheck
--------------------------------------

















프로그램 실행 후
주민번호 입력: 930904-105XXXX
                    '9' 
[처리 결과]
----------------------------
나이: ?
성별: 남자
출신도: 서울
띠: 닭띠
생년월일: 1993/09/04
----------------------------



 






프로그램 실행 후
주민번호 입력: 930904-105XXXX
                     "93" => 93 
--------------------------------------------------------
 '나이' 얻어내는 시나리오 설정(문제 해결 방법론)
--------------------------------------------------------
  1. 현재 시스템에서 년도 얻어옴 => 2014  ▶ Calendar 클래스 활용
     Calendar cal =  Calendar.getInstance(Locale.KOREA);
     int year = cal.get(Calendar.YEAR);
  2. 주민번호 앞2자리를 얻어온다 "93" => 93 변환
     => String 클래스의 substring(int, int)
  3. charAt(7) 의 값이 1,2(1900년 이전 출생) or 3,4(2000년 이후 출생) 판단
       1,2 면 => 1900+93 = 1993
       3,4 면 => 2000+ ?  = ?
  4. 2014 - 1993 + 1 = 본나이
------------------------------------------------------









[힌트]
가중치 배열 선언
  int weight[] = {2,3,4,5,6,7,0,8,9,2,3,4,5};

String 클래스의 chatAt( ) 메소드 활용
 char charAt(int index)
    => 기능: Returns the char value at the specified index. 
                An index ranges from 0 to length() - 1. 
                The first char value of the sequence is at index 0, 
                the next at index 1, and so on, as for array indexing. 
-------------------------------------------------------------------------------
  String juminNo;
  juminNo.charAt(7)   =>   '1'

  문자열은 index가 0부터 시작한다. 
  ※ 제어문 => for문, if문, continue문 활용하여 해결한다.








※ 주민번호 정상 유무 체크 공식
---------------------------------------------
   1단계:  X X X X X X - X X X X X X X
             2  3 4 5  6 7   8  9 2 3 4  5 ▶ 체크숫자(check digit)

       sum = X * 2 + X * 3 + ........ X * 5       

   2단계:  temp = 11 - (sum % 11)

   3단계:  result = temp % 10
--------------------------------------------------------
     만일 result == 체크숫자  => 주민번호 정상
            result != 체크숫자   => 틀린주민번호
-------------------------------------------------------
※ sum + temp = 11의 배수
---------------------------------
3단계는 temp 값이 2자리인 주민번호를 위해서 필요
------------------------------------------------------
[힌트]
   //가중치 선언
   int weight[] = {2,3,4,5,6,7,0,8,9,2,3,4,5};

  ※ String 클래스에 charAt( ) 메소드 활용한다.
       => char charAt(int index)

   주민번호 입력:  930904-105XXXX
                        '9'
                        57-48 =9

               int sum=0;
               for(i=0;        ){          
                     sum = sum + (juminNo.chatAt(i)-48) * weight[i]


  <아스키 코드값>
     '0' => 48
     'A' => 65
     'a' => 97
-------------------------------------------------------------------------------
주민번호 정상 출력

    "나이"를 얻어내기 의한 시나리오 작성
      (1) 현재 시스템 년도를 구하기 => 2013 => Calendar 클래스 적용
                   public static Calendar getInstance(Locale aLocale)

                      => Calendar cal =  Calendar.getInstance(Locale.KOREA);
                           int year = cal.get(Calendar.YEAR);

      (2) 주민번호 앞 두자리 추출 => 문자열 => 정수 변환 
                                                                   93 + 1900 = 1993




         (예) 931024-1034365
          public String substring(int beginIndex, int endIndex)
               => Returns a new string that is a substring of this string. 
                    The substring begins at the specified beginIndex and extends 
                    to the character at index endIndex - 1. 
                    Thus the length of the substring is endIndex-beginIndex. 
                     시작인덱스 위치 부터 ~ (끝인덱스 - 시작인덱스 자리 만큼) 

              int yy  = Integer.parseInt(juminNo.substring(0,2));
                               0 ~ (2-0) 자리 만큼만 얻어오기 => "93" => 93













              charAt(7) 의 값이 1,2 or 3,4 판단
       		1,2 면 => 1900+93 = 1993
       		3,4 면 => 2000+ ?  = ?
              if((juminNo.charAt(7) - 48) < 3) 
                      yy = yy + 1900;
              else 
                     yy = yy + 2000;
      (3) 2013 - 1993 = 나이 추출
             int age = year - yy + 1;    //본나이

















 String 클래스의 중요 메소드
        compareTo()
        equals()
        charAt()
        substring()
----------------------------------------------------------------
◆ 출생 지역코드(주민번호 뒤자리중 2~3번째 자리)
    서울    : 00 ~ 08
    부산    : 09 ~ 12
    인천    : 13 ~ 15
    경기도 : 16 ~ 25
    강원도 : 26 ~ 34
    충북    : 35 ~ 39
    충남    : 40 ~ 47
    전북    : 48 ~ 54
    전남    : 55 ~ 66
    경북    : 67 ~ 76
    대구    : 77 ~ 80
    경남    : 81 ~ 90
    제주도 : 91 ~ 95
------------------------------------------------
◆ 읍,면,동사무소 고유번호(주민번호 뒤자리중 3~4번째 자리)    


 ▶ "띠" 처리 방법=> 출생년도 % 12 => 나머지 값 으로 결정한다

     0 : "원숭이"
     1 : "닭"
     2 : "개"
     3 : "돼지"
     4 : "쥐"
     5 : "소"
     6 : "호랑이"
     7 : "토끼"
     8 : "용"
     9 : "뱀"
    10 : "말"
    11 : "양"
---------------------------------------------
















java.lang 패키지의
 => String 클래스의 
    <중요 메소드>
      => char charAt(int index) 

      => String substring(int beginIndex, int endIndex)
           공식: beginIndex 위치부터  ~ endIndex-beginIndex 자리 만큼 얻어오는 
                                                                                     메소드
          (예) 주민번호에서 앞 두자리만 추출 => substring(0,2)
-------------------------------------------------------------------------









[주의]
실행 후 주민번호 14자리가 입력되지 않았을 때
다음과 같은 예외(Exception)가 발생한다

주민등록번호 입력: 930904-10531
----------------------------------------
Exception in thread "main" java.lang.StringIndexOutOfBoundsException: 
     String index out of range: 12
     at java.lang.String.charAt(String.java:658)
     at JuminCheck.main(JuminCheck.java:17)
------------------------------------------------------------
StringIndexOutOfBoundsException
   => 클래스가 가지고 있는 문자열의 길이에 맞지 않는 
        공간에 접근하고자 할때 발생하는 예외이다
       위의 소스 경우
       ※ 12번째 문자를 요구하기 때문에 문제 발생 
             => 12번째 문자는 없는데. . . 
------------------------------------------------------
<소스>
 16     for(int i=0; i<13; i++){
 17         if(juminNo.charAt(i) == '-')
 18               continue;
 19         else
 20               sum = sum + (juminNo.charAt(i)-48)*weight[i];
 21     }
-----------------------------------------------------------------------









      871025 - 1023456
      //나이 추출 => 시나리오 설정
      ----------------------------------
      (1) 현재 시스템의 연도얻기=> 2013
      (2) 주민번호에서 앞 두자리만 추출 => substring(0,2) => "87" => 정수로 변환 87
      (3) index 7인 자리가 => 1, 2   or  3, 4
           1, 2면  => 1900 + 87 = 1987
           3, 4면  => 2000 + ?
      (4) 2013 - 1987 = 나이
      
     

















//나이 추출
========
1. 시스템의 년도 얻어오기
2. 주민번호의 앞 두자리를 얻어낸다 => substring(0,2) => 정수로 변환 
3. charAt(7)-48  => 1, 2 or 3, 4 비교 판단
                             1, 2 면 => +1900
                             3, 4 면 => +2000




//나이 추출
//년월일시분초 얻어내기
Calendar cal = Calendar.getInstance(Locale.KOREA);
int year = cal.get(Calendar.YEAR);   //2013를 얻어옴

int yy = Integer.parseInt(juminNo.substring(0,2));
if((juminNo.charAt(7)-48) < 3) yy = yy + 1900;
else yy = yy + 2000;

int age = year - yy + 1;     
System.out.println("나이: " + age);







     
---------------------------------------------------
static Calendar getInstance(Locale aLocale)
   => 어떤 메소드가 static 메소드면 클래스이름으로 호출가능





<프로젝트 30>
프로젝트이름 : 금액을 화폐단위로 변환하기
클래스이름   :  ChangeMoney
----------------------------------------------


























[참고]
  - 자바는 '추상화'를 위해 제공하는 가장 유용한 도구는
    바로 interface이다
    interface는 자신을 구현한 클래스에 대한 구체적인 정보는
    모두 감춰버린다
  - interface는 '어떤 일'을 하겠다는 '기능'만 정의해 놓은 것이다 => "추상 메소드" 개념
    따라서 interface는 '어떻게' 하겠다는 구현 방법은 나타나 있지 않다
 
  ※ '추상화'란?
      : 어떤것들의 '공통적인 성격'을 뽑아내어 이를 따로 분리해 내는 작업을 의미한다  


==============
예외처리(Exception)
==============
예외란?
문법적 에러나 버그와는 다르게 실행시간에 프로그램의
흐름을 방해하는 '모든 프로그래밍적 상황'을 의미한다

자바에서는 예외를 발생시키는 것을 '던진다(throw)'고
표현하며 그 예외를 처리하는 것을 잡는다(catch)고 표현하며
예외가 발생되는 시점을 나누어 처리하도록 하고 있다
-------------------------------------------------------------------
[참고]
예외의 주목적 - 프로그램 실행 중 예외가 발생할 때 프로그렘에서
                    예외처리를 따로 하지 않으면 프로그램을 강제 종료가 된다.
예외란?  - 프로그램의 실행 중에 런타임 오류의 발생을 응용 프로그램에게 
             알리는 행위이다.
---------------------------------------------------------------------------------  








<프로젝트 31>
프로젝트이름 : 예외처리1
클래스이름    : Test1
------------------------------ 
















  

int a = 12;
int b = a / 0;


   int a[ ] = new int[3];
   a[4] = 10;


    
<프로젝트 32>
프로젝트이름 : 예외처리2
클래스이름    : Test2
------------------------------ 

<프로젝트 33>
프로젝트이름 : 예외처리3
클래스이름    : Test3
-----------------------------
 ※ 자바 언어의 두 가지 특징
    (1) 객체지향 언어(OOP)
    (2) 이벤트 처리 중심 언어
--------------------------------















  
[실행결과]  
배열의 크기를 벗어남: java.lang.ArrayIndexOu
















<프로젝트 27>
프로젝트이름 :  자바어플리케이션 설계방식1
패키지이름    :  sample1
클래스이름   :   HelloApp
                    MessageBean
------------------------------------------------










 

<프로젝트 28>
프로젝트이름 :  자바어플리케이션 설계방식2
패키지이름    :  sample2
인터페이스    :  MessageBean
클래스이름   :   HelloApp
                    MessageBeanEn
                    MessageBeanKr
---------------------------------------------------
                     















검색할 숫자는? 50

                  " 50"



































   




























지금부터=>
Window 프로그램(GUI 프로그램) 작성
===================
<자바 GUI 컴포넌트의 종류>
===================
  (1) AWT 컴포넌트 => 중량(heavy weight) 컴포넌트
                                 운영체제(OS)의 도움을 받아 화면에 출력
                                  ▶ java.awt 패키지에 포함 되어 있다

  (2) Swing 컴포넌트 => 경량(light weight) 컴포넌트
                                  운영체제(OS)의 도움을 받지 않고 구현
                                  순수 자바 언어로 작성
                                  AWT와 구분하기 위해 대문자 'J'로 시작한다
                                    ▶ javax.swing 패키지에 포함 되어 있다
---------------------------------------------------------------------------------
[차이점]
  이미지 객체를 생성하는 생성자가 있느냐, 없느냐에 따라?
      => Button과 Label 클래스의 생성자    => 없음
      => JButton과 JLabel 클래스의 생성자 => 있음
------------------------------------------------------------











   I18N => 국제화 Internationalization
   => JSP 과정 



----------------                                 ------------------
AWT 컴포넌트                  l              Swing 컴포넌트
----------------                                 ------------------
Button                                            JButton
Checkbox                                        JCheckBox
CheckboxGroup => 논리적 그룹화
CheckboxMenuItem                         JCheckBoxMenuItem
Choice                                             
                                                      JComboBox
Component                                     JComponent
Container
Dialog                                            JDialog
FileDialog
                                                      JFileChooser
Frame                                             JFrame
Image                                             ImageIcon
Label                                              JLabel
                                                      JList
MenuBar                                         JMenuBar 
Menu                                              JMenu 
MenuItem                                        JMenuItem
MenuShortcut
                                                       JOptionPane
Panel                                               JPanel
                                                       JPasswordField
                                                       JSpinner
                                                       JRadioButton
                                                       ButtonGroup => 논리적 그룹화
ScrollPane                                        JScrollPane 
                                                       JSlider
                                                       JSplitPane
TextArea                                          JTextArea
TextField                                          JTextField
Window
Toolkit
Dimension
                                                       JTable
                                                       JTabbedPane
                                                       JToggleButton
                                                       JTollBar
                                                       JTree
------------------------------------------------------------------ 

   java.awt.event 패키지












[참고]
Java의 레이아웃 관리자 => 컴포넌트 배치 방법 관리자 생성

   (1) BorderLayout => 동,서,남,북,중앙 배치                     => setLayout(new BorderLayout())
   (2) FlowLayout   =>  왼쪽에서 오른쪽으로 배치              => setLayout(new FlowLayout())
   (3) GridLayout    =>   2차원 배열 형태의 배치(행,열 배치) => setLayout(new GridLayout())
   (4) CardLayout   =>   몇 장의 카드를 바꿔가면서 배치      => setLayout(new CardLayout())
   (5) 사용자 임의(자유) 배치 => setLayout(null)
--------------------------------------------------------------------












[참고]
----------------------------------------------------------------------
GUI 프로그램 작성시 => 컴포넌트 자동배치 방법
이클립스 - [Help] 메뉴 - Eclipse Marketplace
               Find 란에 visual editor 입력 후
               Eclipse Visual Editor => install

Visual Editor 다운로드 사이트 => http://ehecht.com 접속 후 다운
-----------------------------------------------------------------------







<프로젝트 34>
프로젝트이름 : 버튼 컴포넌트 이벤트처리
클래스이름    : ButtonEvent
---------------------------------------------












[참고]
  @Override 의미?
    @ 어노테이션(Annotation) => '주석' 개념
     @Override란? => 현재 메소드(즉 actionPerformed( ))가 
                             ActionListener의 추상 메소드를 오버라이드한 
                             메소드임을 컴파일러에게 명시하는 개념
--------------------------------------------------------------------------------


















   ★ 멤버 - 필드
                메소드

      <차이점>
   -------------------------------------------          ------------------------------------
           non-static 멤버                                           static 멤버
   -------------------------------------------          ------------------------------------
     = 인스턴스 멤버                                            = 클래스 멤버
     - '객체'가 생길 때 객체 내부에 하나씩 생성        - '객체'를 생성하지 않고도 사용 가능
     - 객체마다 자신의 고유한 멤버공간을 가지며      - 클래스당 하나만 생성
       객체들이 공유하지 않는다
     - 객체가 생성할 때 멤버도 생성                        - 동일한 클래스의 모든 객체들에 의해 공유된다
     - 객체가 사라지면 non-static 멤버도                - 클래스 로딩시 멤버 생성됨
       함께 사라진다                                             - 객체가 생기기 전에 이미 생성
                                                                       - 객체가 생기기 전에도 사용 가능하다
   -----------------------------------------------      -------------------------------------------




















-------------------------------------
<프로젝트 35>
프로젝트이름 : 행운의 로또번호 발생기
클래스이름    : LottoGetNumber
-------------------------------------
[시나리오 설정]
1. 난수 발생 => 1 ~ 45 사이에 난수 발생
2. 난수를 배열(자료구조)에 저장 => 중복 배제=> 알고리즘 구상
3. 배열에 데이터=> 정렬 알고리즘 적용
4. 배열에 데이터 출력
---------------------------------------------------------------------
  java.util 패키지의
      Random 클래스=> nextInt() 메소드 활용

         (예) nextInt(45)+1   => 1 ~ 45 난수 발생















[시나리오 구상]
1. 난수 발생 : 1 ~ 45
2. 숫자 중복없이 배열에 저장 => logic 구상
3. 정렬 시키기 => 선택 정렬 알고리즘 적용
4. JTextField 컴퍼넌트에 6개 숫자 객체 출력하기
-------------------------------------------------------
java.util 패키지의
 Random 클래스
   [난수 발생 시키는 메소드]
       => nextInt(45) => 0 ~ 44까지 난수 발생
            nextInt(45) + 1 => 1 ~ 45까지 난수 발생
--------------------------------------------------------













[참고]
<자바에서 배열 생성 방법 두 단계>
  1. 배열에 대한 레퍼런스 변수 선언
  2. 배열 생성
---------------------------------------
(예)  int lottoNum [];
       lottoNum = new int[6];    

※ 배열의 선언과 동시에 생성
   int lottoNum[] = new int[6];   // 0 으로 자동 초기화가 된다.


















[참고] 컴퍼넌트 배치 => FlowLayout으로 한다
  








=====================  
* String 클래스의 중요 메소드
=====================
   int  compareTo(String 타입)
   boolean  equals(String 타입)
   char charAt(int 타입)
   String substring(int, int)
   String valueOf(int)
   int length()
-------------------------------------
















<프로젝트 36> => 실무에서 코딩 방법
프로젝트이름 : 로또번호 발생기(ArrayList 적용) 
클래스이름    : LottoGetArrayList
----------------------------------------------------
[시나리오 설정]
1. ArrayList 객체 생성 후 => Integer 클래스를 이용하여 정수를 객체화 1 ~ 45를 저장
2. 객체들을 섞는다
3. 객체들 중 앞에서 6개 객체를 선택한다
4. 6개 객체를 객체 정렬한다
5. 출력
---------------------------------------------------------------
[참고]
 java.util 패키지의 ArrayList 클래스의
      List<E> subList(int fromIndex, int toIndex)

       Parameters:
                    fromIndex - 하단점; low endpoint (inclusive) of the subList
                    toIndex     - 상단점; high endpoint (exclusive) of the subList
------------------------------------------------------------------------------------

  non-static 메소드












[시나리오 작성]
===========
1. 먼저 ArrayList 객체 생성 후 => Integer 객체 1 ~ 45 까지를 저장(add)
2. 객체들을 흔든다(섞는다)
3. 앞에서 6개의 객체를 얻어온다
4. 객체 오름차순 정렬 시키기
5. 출력
------------------------------------------------------------------------
java.util 패키지의
   => ArrayList 클래스의 메소드
         List<E> subList(int fromIndex,  int toIndex)
                   => 기능: Returns a view of the portion of this list between 
                               the specified fromIndex, inclusive, and toIndex, exclusive
              Parameters:
                               fromIndex - low endpoint (inclusive) of the subList
                               toIndex - high endpoint (exclusive) of the subList
-------------------------------------------------------------------------------------------------- 














[힌트]
앞에서 6개의 객체를 얻어온다
  => ArrayList 클래스의 subList(인자1 ,인자2) 메소드 활용
                                   => 반환값: List<Integer>
---------------------------------------------------------------
public List<E> subList(int fromIndex, int toIndex)












[참고]
list.add(i);  => list.add(new Integer(i)); 로 변환

* 박싱(boxing) 이란? 기본 데이터 타입을 Wrapper 클래스로 변환하는 것
  JDK 1.5부터 자동박싱 지원 
---------------------------------------------------------------------------------












<프로젝트 37>
프로젝트이름 : 체크박스 테스트
클래스이름    : CheckboxTest
---------------------------------------
java.awt 패키지의 Checkbox 클래스의
  [생성자]
            Checkbox(String label, boolean state) 
                 □ '사각형' 모양의 체크박스 생성

            Checkbox(String label, boolean state, CheckboxGroup group) 
                 ○ '원' 모양의 체크박스 생성

java.awt 패키지의 CheckboxGroup 클래스의
  [생성자]
            CheckboxGroup()  ▶ 체크박스들을 종속적인 관계로 "논리적" 그룹화 시킨다
-------------------------------------------------------------------------------------------


























 


<프로젝트 39> => 강의자료 55쪽 실습
프로젝트이름 : 체크박스 이벤트처리 응용 
클래스이름    : CheckboxEventTest
---------------------------------------------
[힌트]
  JFrame은 최상위 컨테이너 개념
  Panel은   작은 컨테이너 개념
---------------------------------------------
  Panel    p;

  p = new Panel();
  체크박스 객체 생성 후 
  p.add(cb1);
  p.add(cb2);
--------------------------------




[참고]
JFrame은 윈도우 이벤트 핸들링을 하지 않아도 
윈도우를 종료할 수 있다.
이는 내부적으로 이벤트 핸들링 코드가 존재하기 때문이다.














[이벤트 핸들러 처리를 위해 필요한 메소드]
  java.util.EventObject 클래스로 상속받은 => getSource() 메소드 사용
     l--> java.awt.event.ItemEvent

    [메소드]
        Object getSource() => 이 메소드는 반드시 (객체형변환)을 해주어야 한다.
                    => The object on which the Event initially occurred.

  java.awt 패키지의  
     => Checkbox 클래스
            [메소드]
               void setState(boolean state) 기능=> 체크 유무 결정
               boolean getState()              기능=> 체크박스의 상태를 리턴
                                                                   선택시 true, 
                                                                   선택되지 않았다면 false 리턴
---------------------------------------------------------------------------------------------------





		












<프로젝트 40>
프로젝트이름 : 제이체크박스 컴포넌트 이벤트처리
클래스이름    : JCheckBoxEvent
-----------------------------------------------------
[참고]
int getStateChange()

 Returns the type of state change (selected or deselected).
 Returns:an integer that indicates whether the item was selected or deselected
 See Also:SELECTED, DESELECTED
















이벤트 핸들러 처리 => 추상 메소드 재정의
[힌트]
java.awt.event 패키지
   => ItemEvent 클래스
          [이벤트 핸들러 처리시 => 필요 메소드]
            int getStateChange()
                 기능: 체크박스의 상태변화를 리턴하는 메소드
                        선택된 경우  ItemEvent.SELECTED를,
                        해제된 경우에는 ItemEvent.DESELECTED를 리턴한다
            Object getItem() 
                      기능: 이벤트를 발생시킨 Item 객체를 리턴하는 메소드
----------------------------------------------------------------------------------
어떤 과일을 선택 or 해제 둘 중 하나?
   => selected 변수 선언
        먼저  selected = 0; 으로 초기화 시킨 후
               선택시 => selected = 1;
               해제시 => selected = -1;
------------------------------------------------------




 int selected = 0; 
 if(e.getStateChange() == ItemEvent.SELECTED)
      selected = 1;
 else 
      selected = -1;
-------------------------------
JLabel sumLabel;
int sum=0;   //전역변수

//생성자 안에서
sumLabel = new JLabel("현재 0원 입니다.");

//추상 메소드에서 코딩
이벤트 발생 처리 후 sum 누계

sumLabel .setText("현재 "+sum+"원 입니다.");
------------------------------------------------------












<프로젝트 41>
프로젝트이름 : 제이라디오버튼 이벤트처리
클래스이름    : JRadioButtonEvent
---------------------------------------------


















프로젝트 생성 후
 =>프로젝트이름을 선택한다
     "제이라디오버튼 이벤트처리" 선택 => 오른쪽 마우스 눌러
                                            => New => Folder => images 입력 => 폴더 생성




















 http://blog.naver.com/king5901 에서
      자바 강의자료 => 이미지 파일(과일) 카테고리에서
                               => 3개 .jpg 파일 여러분 폴더에 내려받기 한 후 복사하여
                                    이클립스의 "제이라디오버튼 이벤트처리" 프로젝트의
                                    images 폴더에 붙여넣기
----------------------------------------------------------------------------------------------














javax.swing 패키지
   =>  JLabel 클래스의
           [생성자]     
                JLabel(Icon image)  
                    => 이미지 제이레이블 객체 만드는 생성자
[참고]
JRadioButton은 ButtonGroup을 이용해서
'논리적 그룹화'를 해야 한다.  => 여러개 중 어느 하나만 선택 가능

    ButtonGroup g = new ButtonGroup();
    g.add(JRadioButton 객체레퍼런스변수)
    . . . 
    . . .
-----------------------------------------------------
<생성자>
    => JRadioButton(String text)
-----------------------------------------------------




<힌트>
[이벤트 핸들러 처리에 필요한 메소드]
(1) JRadioButton 클래스의 => boolean isSelected()
                                           => 기능: 제이라디오버튼 상태를 돌려주는 메소드
                                                       즉 토클버튼이 선택되고 있는 경우는 true,
                                                       그렇지 않은 경우는 false 리턴

(2) JLabel 클래스의 => void setIcon(Icon icon)
                                      =>기능: 이 컴포넌트가 표시하는 이미지아이콘을 정의한다
-------------------------------------------------------------------------------------------
































<프로젝트 42>
프로젝트이름 : 제이콤보박스 이벤트처리
클래스이름    : JComboBoxEvent
----------------------------------------------
프로젝트이름 선택
"제이콤보박스 이벤트처리" 선택 => 오른쪽 마우스 눌러
                                                   => New => Folder => images 폴더 생성

 http://blog.naver.com/king5901 에서
          JComboBox(과일 이미지) 카테고리에서
              => 4개 .jpg 파일 여러분 폴더에 내려받기 한 후 복사하여
                  이클립스의 "제이콤보박스 이벤트처리" 프로젝트의
                  images 폴더에 붙여넣기 한다
---------------------------------------------------------------------------------------
  JComboBox(E[] items)

Creates a JComboBox that contains the elements in the specified array. 
By default the first item in the array (and therefore the data model) becomes selected.










<생서자>
     JComboBox(E[] items)
    [예]
    //텍스트 콤보박스 객체 생성                                          //인자값: 배열명
   JComboBox<String> strCombo = new JComboBox<String>(fruits);








javax.swing 패키지 
   => JComboBox 클래스의 
                                           ※배열명을 인자값으로 준다
        [생성자] => JComboBox(E[] items)
                           => 지정된 배열에 요소를 포함하는  JComboBox 객체를
                                생성하는 생성자
---------------------------------------------------------------------------------













  <힌트>
  String fruits[] = {"apple","banana","kiwi","mango"};
    . . . 
    . . .
  //생성자 구현
  //텍스트 콤보박스 객체 생성
  JComboBox strCombo = new JComboBox(fruits);
------------------------------------------------------------








  <힌트>
    ---------------------------------------------------------------------
    [이벤트 핸들러 처리 즉 => 추상 메소드 "재정의"시  필요 메소드]   
    --------------------------------------------------------------------- 
     (1) Object  getSource()

     JComboBox 클래스의 메소드 
     (2) int  getSelectedIndex(); 
                  => 기능: 선택 상태인 아이템의 인덱스번호를 리턴            

     JLabel 클래스의          
     (3) void  setIcon(Icon icon)
------------------------------------------------------------------------


<프로젝트 43>
프로젝트이름 : MouseEvent 처리(로그인 처리)
클래스이름    : MouseEvenTest
--------------------------------------------------
[참고]
이번 프로젝트는 '내부 클래스'를 적용하여 구현한다.

  mousePressed()
    ▶ 마우스 버튼이 눌러졌을 때 호출되는 추상 메소드

  mouseReleased()
    ▶ 마우스 버튼이 떼어질 때 호출되는 추상 메소드
----------------------------------------------------------

<프로젝트 44>
프로젝트이름 : 팝업 다이얼로그 만들기
클래스이름    : JOptionPaneTest
------------------------------------------





★ 다섯번째 과제 => "고객관리 시스템" 자바 최종 프로젝트에서 활용
===========
<프로젝트 45> => 매우 중요=> ※ JOptionPane 클래스 적용한다
프로젝트이름 : 주민번호_정보추출(윈도우 프로그램으로 작성)
클래스이름    : JuminCheck
----------------------------------------------------------------------

<프로젝트 46>
프로젝트이름 : 탭팬 만들기
클래스이름    : TabbedPaneTest
-----------------------------------

<프로젝트 47>
프로젝트이름 : '입력' 보더 만들기
클래스이름    : InputBorderTest
------------------------------------

javax.swing.border 패키지의
  ▶ TitledBorder 클래스의
    [생성자]
       TitledBorder(Border  border, String  title)
            기능: 지정된 경계로 TitledBorder 의 인스턴스를 생성한다 

            파라미터:  border - 경계
                           title - 경계에 표시하는 타이틀
       --------------------------------------------------------------------
    ▶ LineBorder 클래스의
       [생성자]
         LineBorder(Color  color, int thickness)
             기능: 지정된 색과 굵기로 직선 경계를 작성한다

             파라미터:  color - 경계의 칼라
                            thickness - 경계의 굵기
      -------------------------------------------------------------------





  [예]
    JPanel input = new JPanel();
    . . .
    . . .
    input.setBorder(new TitledBorder(new LineBorder(Color.blue, 5), "입력"));



    
<프로젝트 48> 
프로젝트이름 : 카드레이아웃 만들기
클래스이름    : CardLayoutTest
---------------------------------------


















<프로젝트 49> 
프로젝트이름 : JTabel 만들기
클래스이름    : JTableTest
--------------------------------
[참고]
   <생성자>
         JTable(Object[][] rowData, Object[] columnNames)
















java.swing 패키지의 JTabel 클래스
<생성자> 적용
   => JTable(Object[][] rowData, Object[] columnNames)




















* JTabel 클래스의
  [생성자]
     JTable(Object[][] rowData, Object[] columnNames) 

* JScrollPane 클래스의
  [생성자]
     JScrollPane(Component view)
--------------------------------------------











※ 중요
//JTable에서 컬럼명을 클릭했을때 데이터값을 오름차순,내림차순으로 정렬하기
//----------------------------------------------------------------------------------------
table.setAutoCreateRowSorter(true);
TableRowSorter tablesorter = new TableRowSorter(table.getModel());
table.setRowSorter(tablesorter);
















<프로젝트 50> => 중요 => "고객관리 시스템" 프로젝트를 하기위한 준비
프로젝트이름 : JTabel 응용(DefaultTableModel적용)
패키지이름    : mytest
                       l
                       l--> 클래스이름 : JTableCreate     => '화면구성' 클래스
                                               AddAction        => '추가' 기능 클래스
                                               RemoveAction   => '삭제' 기능 클래스
-------------------------------------------------------------------------------
[참고]
<필요 생성자>
     => DefaultTableModel(Object[] columnNames, int rowCount)
---------------------------------------------------------------------------





<프로젝트 51> 중간 결산 프로젝트
프로젝트이름 : 리틀 고객관리 시스템
클래스이름    :  CustomerManage
----------------------------------------
[프로젝트 요구 사항] 
  1. 주민등록번호 체크 공식 포함 한다.
  2. JOptionPane 클래스 이용하여 팝업다이얼로그창을 띄운다.
  3. '추가', '수정','삭제' 이벤트 처리를 한다.
     (단, '수정'은 이름, 핸드폰번호만 수정한다.)
            주민번호는 수정하지 못하게 막아논다  
--------------------------------------------------
<전체적인 틀 구성>
  외부 클래스 => CustomerManage

       입력보더 만들기 내부 클래스 => West
    
       버튼들 만들기 내부 클래스    => Buttons

       JTable 만들기 내부 클래스    => ShowTable
-----------------------------------------------------
[참고] '수정' 버튼 이벤트 처리에 필요한 메소드

     Object getValueAt(int row, int column)
          => Returns the cell value at row and column. 

     void setValueAt(Object aValue, int row, int column)
          => Sets the value for the cell in the table model at row and column. 

          Parameters:
                            aValue - the new value
                            row - the row of the cell to be changed
                            column - the column of the cell to be changed
---------------------------------------------------------------------------
[참고]
  Vector<String> vec = new Vector<String>();

  ※ 중요
  Vector<Vector<String>> data;
    












javax.swing.table 패키지의
  =>  DefaultTableModel 클래스
         <생성자> 필요
               => DefaultTableModel(Object[] columnNames, int rowCount)











(예)  클래스 객체 생성 공식 
       클래스이름 인스턴스변수 = new 클래스이름();

       JLabel  name = new JLabel("이름"); 






















javax.swing.table 패키지의
 * DefaultTableModel 클래스
  [생성자]
    DefaultTableModel(Object[] columnNames, int rowCount)    

    ※ "고객관리시스템" 프로젝트 구현시 사용
          => DefaultTableModel(Vector data, Vector columnNames)   
-----------------------------------------------------------------------------
javax.swing 패키지의
* JTabel 클래스
  [생성자]
    JTable(TableModel dm)
-----------------------------------------------
javax.swing.table 패키지의
 * DefaultTableModel 클래스
   [메소드]
         addRow(Object[] rowData)
            기능: Adds a row to the end of the model. 

         removeRow(int row)
            => 기능: Removes the row at row from the model. 







         setDataVector(Vector dataVector, Vector columnIdentifiers)
            => 기능: 현재의 dataVector 인스턴스 변수를 새로운 행의
                         Vector인 dataVector에 옮겨놓는다

         fireTableDataChanged()
              => 기능: Notifies all listeners that all cell values in the table's rows may have                                      changed. The number of rows may also have changed and the JTable                                   should redraw the table from scratch. The structure of the table (as in                               the order of the columns) is assumed to be the same.

                          테이블의 행의 모든 셀치가 변경되고 있을 가능성이 있는 것을, 모든 청취자에게                             통지한다. 행수도 변경되고 있는 경우가 있어, JTable 는 테이블의 draw를 최초                            부터 다시 할 필요가 있다. 

                          테이블에 저장된 데이터가 변경되었고 그 내용을 화면에 반영해야할 
                          경우에는 TableModel에서 이 메소드를 호출하여 Table에 데이터이
                          바뀌었음을 알려주는 이벤트 발생시켜야 한다  
---------------------------------------------------------------------------------------------
javax.swing 패키지의
* JTabel 클래스
  [메소드] 
      int getSelectedRow()
        기능: Returns the index of the first selected row, -1 if no row is selected

      changeSelection(int rowIndex, int columnIndex,   
                            boolean toggle, boolean extend)
       기능: toggle 와 extend 의 2 개의 플래그 상태에 의해, 테이블의 선택 모델을 갱신한다. 
              UI 가 받은 키보드 이벤트 또는 마우스 이벤트에 의해 행해진 선택 범위의 변경은 
              이 메소드에 의해 처리되어 서브 클래스가 동작을 오버라이드(override) 할 수 있게 된다.                  UI 에는, 불연속인 선택 범위의 선두를 조작하는 경우 등, 이 메소드가 제공하는 것보다도                  고도의 기능을 필요로 하는 것도 있어, 일부의 선택 범위의 변경에서는 그러한 UI 가 
              이 메소드에 불러 들여지지 않은 것이 있다.  

       * 구현은 다음의 규칙을 사용한다. 

       toggle:false, extend:false => 기존의 선택을 클리어 해, 새로운 셀이 확실히 선택되도록(듯이)                                             한다 
       toggle:false, extend:true => 기존의 선택을 엥커로부터 지정의 셀까지 확장해, 다른 모든 선택                                            을 클리어 한다 
       toggle:true, extend:false => 지정된 셀이 선택되고 있는 경우, 그 셀을 선택 해제한다. 선택되어                                             있지 않은 경우, 그 셀을 선택한다 
       toggle:true, extend:true => 엥커의 선택 상태를, 그 엥커와 지정된 셀간의 모든 셀에 적용한다. 

       파라미터:
                   rowIndex - row 의 선택에 영향을 주는
                   columnIndex - column 의 선택에 영향을 주는
                   toggle - 상기 참조
                   extend - true 의 경우, 현재의 선택을 확장하는
    --------------------------------------------------------
    <번호, 이름, 출신도, 직업 정렬 작업시 필용한 메소드>
    -------------------------------------------------------------
     int getRowCount()
       => Returns the number of rows that can be shown in the JTable, 
           반환값: JTable에 표시되는 행수
 









-------------------------------------------------------------------------------------------











MVC 패턴 => Model, View, Controler

모달(modal) 타입







---------------------------------------------------------------------------------



[참고]
JTable 사용시 DefaultTableModel을 사용해야 하는 이유?

  => JTable을 생성할 때 JTable에 보여지는 내용은 Model 타입의
      파라미터를 요구한다
      즉, JTable에 자료를 넣고 싶다면 TableModel을 파라미터 값으로 
      넣어야 한다
      JTable 내에 데이터를 '동적'으로 삽입하거나 수정하거나 삭제하기 위해서는
      'Model' 형태를 사용해야 한다  
------------------------------------------------------------------------------------












//Cell의 데이터값을 중앙 정렬 시키기
//---------------------------------------
//1단계: DefaultTableCellRenderer 객체 생성
DefaultTableCellRenderer tableCell =
			new DefaultTableCellRenderer();

//2단계: 렌더러의 가로정렬을 CENTER로
tableCell.setHorizontalAlignment(SwingConstants.CENTER);

//3단계: 정렬할 테이블의 컬럼모델을 가져온다
TableColumnModel CellModel = table.getColumnModel();

//4단계: 컬럼모델에서 컬럼의 갯수만큼 컬럼을 가져와 
//for문을 이용하여 각각의 셀렌더러를 생성한 tableCell에 set 해준다
for(int i=0; i<CellModel.getColumnCount(); i++)
	CellModel.getColumn(i).setCellRenderer(tableCell);
-------------------------------------------------------------------------

<프로젝트 43>
프로젝트이름 : 금액을 화폐단위로 변환하기
클래스이름    : MoneyChange
-------------------------------------------------
[참고]
Java의 레이아웃 관리자 => 컴포넌트 배치 방법 관리자 생성

   (1) BorderLayout => 동,서,남,북,중앙 배치                     => setLayout(new BorderLayout())
   (2) FlowLayout   =>  왼쪽에서 오른쪽으로 배치              => setLayout(new FlowLayout())
   (3) GridLayout    =>   2차원 배열 형태의 배치(행,열 배치) => setLayout(new GridLayout())
   (4) CardLayout   =>   몇 장의 카드를 바꿔가면서 배치      => setLayout(new CardLayout())
   (5) 사용자 임의(자유) 배치 => setLayout(null)
--------------------------------------------------------------------







먼저 화면 구성
   => setLayout(null) => '사용자' 자유 배치 레이아웃 관리자 생성
                                    즉 컴포넌트의 위치를 사용자가 설정해주어야 한다

    * 내부 클래스에서 => 화면구성, 이벤트 처리  
 
    * 화폐단위와 JTextField는 배열로 선언하자
        String text[] = {"오만원","만원",  . . . . . . . . . . . };
        JTextField tf[] = new JTextField[8];










        for(int i=0; i<text.length; i++){

             JLabel인스턴스변수.setHorizontalAligment(JLabel.RIGHT);
             JLabel인스턴스변수.setSize(50,20); 
             JLabel인스턴스변수.setLocation(50, 50+i*20);

        }      
-----------------------------------------------------------------------


































 














javax.swing 패키지의
   JComponent 클래스
   [메소드]
       void setBorder(Border  border)
              => 이 컴퍼넌트의 경계를 설정. 





















Border 객체는, 컴퍼넌트의 인 세트를 정의해 
       (컴퍼넌트로 직접 설정되어 있는 인 세트를 오버라이드(override) 한다), 
       임의로 그러한 인 세트의 경계내의 경계 장식을 draw 한다. 
       Swing 컴퍼넌트로 장식 영역 및 비장식 영역 (마진 및 패딩등)의 양쪽 모두를        생성하려면 , 인 세트는 아니고 경계를 사용할 필요가 있다. 
       단일의 컴퍼넌트내에서 복수의 경계를 상자로 하려면 , 복합 경계를 사용할 수 있다.  
       기술적으로는 JComponent 를 상속하는 어느 객체에도 경계를 설정할 수 있습니다만, 
       표준의 Swing 컴퍼넌트의 Look & Feel 의 구현의 상당수는, 사용자 설정의 경계에서는 
       올바르게 동작하지 않는다. 일반적으로,JPanel 또는 JLabel 이외의 표준의 Swing 
       컴퍼넌트로 경계를 설정할 때는, 컴퍼넌트를 JPanel 에 넣어,JPanel 로 경계를 
       설정하는 것을 추천한다. 








-----------------------------------------------------







javax.swing 패키지의
   JComponent 클래스 
    [메소드]
       void setPreferredSize(Dimension  preferredSize)
          기능: 이 컴퍼넌트의 적절한 사이즈를 설정한다. 
                  preferredSize 가 null 의 경우, UI 로 적절한 사이즈를 요구한다. 
-----------------------------------------
Dimension 클래스
  => 단일의 객체내의 컴퍼넌트의 폭과 높이를 정수 정밀도로를 캡슐화한다. 
       이 클래스는, 컴퍼넌트의 특정의 프로퍼티에 관련지을 수 있고 있다. 
       Component 클래스 및 LayoutManager 인터페이스에 의해 정의되는 
       몇개의 메소드는, Dimension 객체를 돌려준다.  

       일반적으로는,width 와 height 의 값은, 부가 아닌 정수이다. 
       치수를 생성할 수 있는 생성자 에서는, 0 보다 작은 값을 이러한 프로퍼티으로 
       지정해도 에러로는 되지 않는다. width 와 height 에 0 보다 작은 값이 지정되고 
       있는 경우, 다른 객체에 의해 정의된 메소드의 동작은 보증되지 않는다. 
------------------------------------------------------------------------------------











<프로젝트 52>
프로젝트이름 : 툴팁메니저 실습
클래스이름    : ToolTipTest
-------------------------------------
프로젝트이름을 선택한다
"툴팁메니저 실습" 선택 => 오른쪽 마우스 눌러
                                     => New => Folder => images 폴더 생성 후
                                         => cherry.jpg 파일과 apple.jpg 파일 복사하여 붙여넣기
--------------------------------------------------------------------------------------------
<프로젝트 53>
프로젝트이름 : 금액을입력받아 화폐단위 출력
클래스이름    : MoneyChanger
-------------------------------------------------
[조건]
  단, 화면 구성은 사용자 자유배치로 한다.
  setLayout(null); => 컨테이너의 레이아웃을 해제한다.
------------------------------------------------------------ 







<프로젝트 54>
프로젝트이름 : 가위,바위,보 게임 만들기
클래스이름    :  GBBGame 
-------------------------------------------
[참고]
  하나의 클래스 안에
      * 내부 클래스 2개 구현
        MenuPanel => 이미지 버튼 생성, 이벤트 처리 클래스
        GamePanel => 게임의 결과를 보여주는 클래스

프로젝트이름 선택
"가위,바위,보 게임 만들기" 선택 => 오른쪽 마우스 눌러
                                              => New => Folder => images 폴더 생성

 http://blog.naver.com/king5901 에서
          가위,바위,보 게임(이미지) 카테고리에서
              => 3개 .jpg 파일 내려받아 여러분 폴더에 붙여넣기 한 후 복사하여
                   이클립스의 images 폴더에 붙여넣기 한다.
-----------------------------------------------------------------------------------
[힌트]
[게임의 경우의 수]  => 논리 연산자  필요 => && (AND 연산자) ▶ 양쪽조건이 '참'이면 참
                                                               || (OR 연산자)       ▶ 어느 하나라도 '참'이면 참
(1) 사용자가 '승'인 경우     
    사용자     >     컴퓨터
    --------          ---------
       0 (가위)          2(보)
       1 (바위)          0(가위)
       2 (보)             1 (바위) 
(2) 컴퓨터가 '승'인 경우
    사용자     <     컴퓨터
    --------          ---------
       0 (가위)          1(바위)
       1 (바위)          2(보)
       2 (보)             0(가위)
(3) 위의 경우가 아니면 => 비긴 경우
-----------------------------------------











<프로젝트 55> => 중요
프로젝트이름 : 간단한 메뉴 만들기
클래스이름    : MenuMain
----------------------------------------
   파일       정렬           도움말
   -----      ------          ---------
   열기      □번호         프로그램정보
   저장      □이름     
   닫기      □출신도
              □직업      
--------------------------------------------
[참고]
메뉴 만들기 => 객체 붙이는 순서

   JMenuItem 또는 JCheckBoxMenuItem => JMenu => JMenuBar => JFrame
----------------------------------------------------------------------------------------






   





※ Java에서 파일 입출력 관련 실습

<프로젝트 56> => 가장 중요
프로젝트이름 : 메모장 만들기(열기,저장 이벤트 처리)
클래스이름    : MemoTest
--------------------------------
    파일       
    ----- 
    열기     
    저장          
--------------------------------------
[참고]
 * FileReader 클래스
     => 문자 파일(즉 텍스트 파일)을 읽어 들이기 위한 편리한 클래스이다.
          문자 스트림을 읽어들이기 위해서 사용한다.

   스트림(Stream) 이란?
      => '데이터의 흐름'을 의미한다.

   ※ FileReader는 보통 BufferedReader와 같은 high-level 객체로
      둘러싸여 사용한다. 그 이유는=> 데이터를 읽을때 성능을 높이고
                                               더 편리하게 작업하기 위해서이다.

 * BufferedReader 클래스
    => 문자, 배열, 행을 버퍼링하는 것에 의해 
         문자형 입력 스트림으로 부터 텍스트를 효율 좋게
         읽어 들인다.
---------------------------------------------------------------------------------

<프로젝트 57>
프로젝트이름 : 자바 입출력 테스트
클래스이름    : DataStreamTest01
--------------------------------------

<프로젝트 58>
프로젝트이름 : 데이터 파일 읽어오기
클래스이름    : DataStreamTest02
--------------------------------------























[참고]
java.awt 패키지의 
  =>FileDialog 클래스
        [생성자]
            FileDialog(Frame parent, String title, int mode)
                 파라미터 :
                           parent : 부모 윈도우가 될 프레임 의미
                           title     : 다이얼로그의 제목
                           mode  : 파일 '열기'(LOAD)인가 '저장'(SAVE)인가를 결정하는 모드 
        [필요 메서드]
            String getDirectory()
            String getFile()
-------------------------------------------------------------------------------------
java.awt.event 패키지의
  => ActionEvent 클래스
      [필요 메소드]
         =>String getActionCommand()
                기능: Returns the command string associated with this action.
------------------------------------------------------------------------------------------




[참고]
FileReader
=======
이 클래스는 문자 기반으로 파일(즉, 메모장 파일)을 읽을 때 사용한다. 
이 클래스의 readLine() 메서드는 low-level의 입력을 지원하며, 
이 메서드를 사용하면 한 문자, 문자 스트림으로 파일 데이터를 읽을 수 있다.
FileReader는 보통 BufferedReader와 같은 high-level 객체로 둘러싸서 사용한다.
그 이유는 데이터를 읽을 때 성능을 높이고 더 편리하게 작업하기 위해서이다. 
-----------------------------------------------------------------------------------------
FileWriter
=======
이 클래스는 문자 기반으로 파일을 쓸 때 사용한다.
이 클래스의 write() 메서드를 사용하면 문자나 String을 파일에 쓸 수 있다.
FileWriter는 보통 BufferedWriter나 PrintWriter와 같은 high-level Writer 객체로 둘러싸서 사용한다.
그 이유는 데이터를 쓸 때 성능을 높이고, 유연성이 좋은 메서드를 제공하기 위해서이다.
--------------------------------------------------------------------------------------------------------- 








MenuItem 클래스의
  => [생성자] => 단축키가 들어간 메뉴아이템 만들 때 
          => MenuItem(String label, MenuShortcut s)








------------------------------------------------------------
MenuItem의 이벤트 처리는
  => ActionEvent 클래스의 
        => String getActionCommand( ) 가 필요
-------------------------------------------------------------
















<힌트> 
     ▶ '저장' 이벤트 처리
        (1) 먼저 => FileDialog(Frame parent, String title, int mode) 객체 생성 후
                    '저장' 창을 띄운다 => 디렉토리명+파일명 을 얻어온다
    
        (2) BufferedWriter 클래스와 FileWriter 클래스 필요
                => BufferedWriter 클래스의 write() 메소드 사용
      
     ▶ '열기' 이벤트 처리
        (1) 먼저 => FileDialog(Frame parent, String title, int mode) 객체 생성 후
                    '열기' 창을 띄운다 => 디렉토리명+파일명 을 얻어온다

        (2) BufferedReader 클래스와 FileReader 클래스 필요
               => BufferedReader 클래스의 readLine() 메소드 사용

             읽은 내용을 TextArea 클래스 객체에 보여(즉 추가) 줄 때
                => TextArea 클래스의 append() 메소드 사용
-----------------------------------------------------------------------------------------      

















[참고]
ToolTipManager 클래스는 생성자가 없다
그대신 ToolTipManager 객체를 얻어오려면 
sharedInstance() 메소드를 통해서 얻어온다

javax.swing 패키지의
    ToolTipManager 클래스
              [주요 메소드]
              static ToolTipManager sharedInstance()
              void setInitialDelay(int milliseconds)   => 초기 툴팁 출력 지연시간 결정
              void setDismissDelay(int milliseconds) => 툴팁 지속시간을 결정
--------------------------------------------------------------------------------------------


























[참고]
  SwingConstants 인터페이스
    => 화면상에서 컴포넌트의 배치 및 방향 지정을 실시하기 위해서
         사용하는 정수의 컬렉션이다
------------------------------------------------------------------------------









<프로젝트 39> => 중요
프로젝트이름 : 팝업 다이얼로그 만들기
클래스이름    : JOptionPaneEvent
--------------------------------------------



<프로젝트 40> => 매우 중요=> ※ JOptionPane 클래스 적용한다
프로젝트이름 : 주민번호_정보추출(윈도우 프로그램으로 작성)
클래스이름    : JuminCheck
-------------------------------------------------------------------
[힌트]
         JTextField  tf = new JTextField(14);
         . . .
         . . .
          //입력한 주민번호 얻어오는 방법
         //-----------------------------------
         String juminNo = tf.getText();
---------------------------------------------
※ "경고" 메시창 띄우기 할 때 
      String 클래스의 
             =>  int  length( ) 메소드 활용    
                         ▶ 문자열의 길이 구하는 메소드
-----------------------------------------------------------














 





<프로젝트 44> 
프로젝트이름 : 입력 보더(Border) 만들기
클래스이름    : BorderTest
-----------------------------------------

















[참고]
Java의 레이아웃 관리자
   (1) BorderLayout => 동,서,남,북,중앙 배치 => setLayout(new BorderLayout())
   (2) FlowLayout   =>  왼쪽에서 오른쪽으로 배치
   (3) GridLayout   =>   2차원 배열 형태의 배치(행,열 배치)
   (4) CardLayout  =>   몇 장의 카드를 바꿔가면서 배치
   (5) 사용자 임의(자유) 배치 => setLayout(null)
----------------------------------------------------------


















  









<프로젝트 47>
프로젝트이름 : 가위,바위,보 게임 만들기
클래스이름    :  GBBGame 
                          [참고]
                           하나의 클래스 안에
                            * 내부 클래스 2개 구현
                               MenuPanel => 이미지 버튼 생성, 이벤트 처리 클래스
                               GamePanel => 게임의 결과를 보여주는 클래스
프로젝트이름 선택
"가위,바위,보 게임 만들기" 선택 => 오른쪽 마우스 눌러
                                                   => New => Folder => images 폴더 생성

 http://blog.naver.com/king5901 에서
          가위,바위,보 게임(이미지) 카테고리에서
              => 3개 .jpg 파일 내려받아 여러분 폴더에 붙여넣기 한 후 복사하여
                   이클립스의 images 폴더에 붙여넣기 한다.
-------------------------------------------------------------------------------------
[힌트]
[게임의 경우의 수]  => 논리 연산자  필요 => && (AND 연산자) ▶ 양쪽조건이 '참'이면 참
                                                               || (OR 연산자)       ▶ 어느 하나라도 '참'이면 참
(1) 사용자가 '승'인 경우     
    사용자     >     컴퓨터
    --------          ---------
       0 (가위)          2(보)
       1 (바위)          0(가위)
       2 (보)             1 (바위) 
(2) 컴퓨터가 '승'인 경우
    사용자     <     컴퓨터
    --------          ---------
       0 (가위)          1(바위)
       1 (바위)          2(보)
       2 (보)             0(가위)
(3) 위의 경우가 아니면 => 비긴 경우
-----------------------------------------







javax.swing 패키지의 
  JButton 클래스의
  [생성자]
     JButton(Icon icon)  ▶ "이미지 버튼"을 만드는 생성자

  [필요 메소드] => 상속 받은 메소드
     Icon getIcon( ) 
     void setIcon(Icon defaultIcon)    
---------------------------------------





















 C:\"다운로드" 폴더 만든 후
   OracleXeUniv.exe 파일 붙여넣기











* 오라클 설치하면 기본으로 => C:\oraclexe 폴더가 만들어진다

  [시작] - [모든 프로그램] - Oracle Database 10g Express Edition 
                                 - SQL 명령줄 실행 - 클릭













     (1) 톰캣을 설치하면 
          C:\Tomcat7.0 폴더 생성됨

          ▶ 톰캣 실행=> C:\Tomcat7.0\bin\Tomcat7.exe 파일 더블 클릭
          ▶ http://localhost:8080/ => 톰캣 로그가 화면이 뜨면 톰캣이 정상 가동

     (2) 오라클 접속 포트 변경
         - 오라클 10gXE는 모든 관리를 웹 기반으로 제공하는데
           이때 사용하는 웹 접속 포트(port)가 8080 으로 되어 있다
         - 포트란? 네트워크 서비스를 받아들이기 위한 창구 개념이다

         - 그런데 톰캣이 기본으로 8080 포트를 사용하는
           상황에서 오라클에서도 8080을 사용하게 되면 충돌이
           발생해 정상적인 운영이 어렵게 된다
         - 이 문제를 해결하려면 오라클 포트를 변경해 주어야 한다

       [참고]
        아펙스(Apex)란?
                => Application Express의 약자로
                     Oracle XE에서는 기본적으로 Apex를 제공한다
                     웹으로 DB를 컨트롤 할 수 있는 웹 애플리케이션을 말한다
----------------------------------------------------------------------------------

 자바 어플리케이션에서 Oracle 데이터베이스 연동 => JDBC 가 필요

  C:\ 드라이브에 OracleXE 폴더가 있는지 확인요
--------------------------------------------------------------------------
   Oracle 설치 방법 => next 계속 눌러
        sys, system 계정의 암호를 물어보는 창이 뜨면
        암호: oracle
        암호: oracle 주고
      => next 계속 누름
----------------------------------------------------------------
  설치가 완료되면 
   => C:\ 드라이브에 OracleXE 폴더가 생김
----------------------------------------------------------------













[오라클 웹 port 번호 변경하기]
====================
[시작] - [모든 프로그램] - Oracle Database 10g Express Edition - SQL 명령줄 실행 - 클릭

  SQL 명령줄 실행 창을 띄운 후

  SQL> conn /as sysdba
  SQL> exec dbms_xdb.setHTTPPort(9000);
















  웹 브라우저 뜨운 후
     => http://localhost:9000/apex    












------------------------------------------------------------
* Java Application 에서 Oracle Database에 연동하려면
====================================
  sysdba 계정으로 접속 후

  (1) 계정 생성(암호 포함)  
  (2) 그 계정에 권한 부여   ▶ connect, resource 롤 권한 부여
  (3) 그 계정으로 DB에 접속
  (4) 테이블 생성
  (5) 데이터 입력
  (6) commit;   ▶ 반드시~해야 한다
  (7) select 작업
----------------------------------------------------------------















시작 => 프로그램 => Oracle 10g
오라클 SQL 명령줄 실행 창 띠워놓고 => 계정 생성, 권한 부여




SQL 명령줄 실행 창 띄워놓고
계정 생성
========================
SQL> conn /as sysdba
SQL> create user testdb identified by testdb123;
SQL> grant connect, resource to testdb;

오라클 데이터베이스에 접속
SQL> conn testdb/testdb123
-----------------------------------
 부서, 사원, 호봉 테이블 생성한 후 => 데이터 입력
======================
 현재 접속한 계정이 사용가능한 테이블들 확인하기

 SQL> select * from tab;
 












     connect 명령어 => 약자 conn 가능




















SQL> desc  dept;
SQL> select * from dept;

SQL> desc  emp;
SQL> select * from emp;
 
SQL> desc  salgrade;
SQL> select * from salgrade;

        where  name  like '김%'

       where dong  like  '개포1동%' 


















* 테이블 삭제 방법
 SQL> drop table 테이블명;

==========================
※ 가상 테이블(view) 실습은 나중에~~~
==========================
SQL> conn system/system
SQL> grant create view to test;
SQL> conn test/test123
SQL> create view emp_20
         as select *
         from emp
         where deptno=20;

SQL> desc emp_20;

SQL> select * from emp_20;



     26개  페이지당 10개
                                      start   end
     [3] 페이지=> 6개     => 21  ~  26

     [1][2][3].........


SQL> select rownum, dname
        from dept;

SQL> select deptno,dname,loc
        from dept;
----------------------------------------------------------------
emp_alter 테이블 변경
===============
복사본 만드는 방법

SQL> create table emp_alter
        as select * from emp;

SQL> select * from emp_alter;

SQL> alter table emp_alter
         add (phone varchar2(14));

SQL> desc emp_later;

[참고]
emp_alter 테이블에 '국적'을 나타내는 country 컬럼을
추가하고 기본값을 'KOREA'로 지정해라

SQL> alter table emp_alter
        add(country char(5) default 'KOREA');
----------------------------------------------------
<컬럼의 데이터 타입 변경>
SQL> alter table emp_alter
        modify phone varchar2(18);

SQL> desc emp_alter;

<주석 추가 방법>
============
1) '테이블'에 추가하는 방법
2) '컬럼'에 추가하는 방법

SQL> comment on table emp_alter
        is '사원 정보를 관리하기 위한 테이블';
SQL> desc emp_alter;

SQL> select *
        from user_tab_coments
        where table_name = 'EMP_ALTER';

SQL> comment on column emp_alter.ename
        is '사원이름';

SQL> select *
        from user_col_commnets
        where table_name = 'EMP_ALTER';
----------------------------------------------------
<테이블 이름 변경>
=============
SQL> rename emp_alter to 사원_구조변경_테이블;

SQL> select * from tab;
------------------------------------------------------------
DBMS_OUTPUT.PUT_LINE('급   여 : ' || LPAD(TO_CHAR(emp_record.sal, '$999,999.00'),13);



***4560




















원자성(Atomicity)
============
일반적으로 원자란 더 이상 나눌 수 없는 가장 작은 단위의 개념을 일컫는 말이다. 
이처럼 트랜잭션도 작업 프로세스를 구성하는 하나의 원자로서 더 이상 나눌 수 없는 
단위의 것이다. 
이러한 원자적인 성격은 All or Nothing이라는 말로 표현되기도 하는데 
이는 트랜잭션이 전부 성공하거나 아니면 전부 실패해야만 한다는 것이다. 
따라서 트랜잭션의 결과는 성공과 실패뿐, 어떤 하위 부분만 부분적으로 
성공해서는 트랜잭션이라 할 수 없다.
--------------------------------------------------------------------------------------------





















 



























[참고]
롤(role)이란?
  => 오라클에서는 롤을 통해서 권한 관리를 쉽게 할 수 있다.
       오라클 데이터베이스를 생성하면 기본적으로 몇 가지의 Role이 생성된다

=> 시작 - 실행 - \\211.48.40.101

  C:\park\OracleIns 폴더 공유 => 오라클설치 파일 다운받기





SQL> connect /as sysdba
SQL> select * from dba_roles;

        ROLE                 PASSWORD
        ----------            --------------     
        CONNECT                NO
        RESOURCE               NO
        DBA                        NO
-------------------------------------------------

* CONNECT 롤(role)
   => 데이터베이스에 접속할 수 있는 기본 권한 롤 
        CONNECT 롤이 없으면 유저를 생성하고서도 Oracle에 접속 할 수가 없다

* RESOURCE 롤
   => 기본적인 오라클 객체(테이블, 인덱스, 뷰 등...)들을 생성/변경/삭제할 수
        있는 권한 롤

* DBA 롤
    => 데이터베이스를 관리하기 위해 필요한 권한을 가진 롤
--------------------------------------------------------------------












* 사원 테이블 생성
[ employee 테이블 ]
==============
   create table employee 
   (no number(3) not null primary key,    --사원번호
    name varchar2(15),                           --이름
    position varchar2(10),                       --직책
    deptno number(2),                           --부서번호
    email varchar2(30)                           --이메일주소
   );
-------------------------------------------------------------
SQL> insert into employee values(1,'김의실','부장',10,'kim123@hanmail.net');
SQL> insert into employee values(2,'박태호','과장',20,'park567@empas.com');
SQL> insert into employee values(3,'손유일','대리',20,'justice@naver.com');
-----------------------------------------------------------------------------------------
SQL> commit;







 SQL> select * from tab;

  * 제약조건
    기본키(primary key) => 반드시 not null 이어야 한다.
                                      데이터들을 유일하게 식별하기 위해서 









  <employee 테이블에 데이터 삽입(insert)>
-----------------------------------------------------
  insert into employee values(1,'김의실','부장',10,'kim123@hanmail.net');
  insert into employee values(2,'박태호','과장',20,'park567@empas.com');
  insert into employee values(3,'손유일','대리',20,'justice@naver.com');
------------------------------------------------------------------------------------
  * 주의 => 데이터 삽입 후 꼭~~~해야하는 작업
  SQL> commit;    //주기억장치에 있는 데이터들을 => 보조기억장치에 저장하는 명령어


 SQL> select * from employee;

SQL> desc employee;       //테이블 구조(컬럼명,자료형,제약조건)를 
                                        보는 명령어=> describe(약자 가능 desc)










SQL> select * from tab;

SQL> describe employee;





  SQL> select * from employee;








   번호     이름       직책        부서번호     이메일


   --------------------------------------------------------------------------
    BOF(Beginging of File)
   --------------------------------------------------------------------------
    1	김의실	부장	10	kim123@hanmail.net
    2	박태호	과장	20	park567@empas.com
    3	손유일	대리	20	justice@naver.com
   --------------------------------------------------------------------------
    EOF(End of File)
   --------------------------------------------------------------------------















 [확인] SQL 명령 실행 창 띄워놓고
 SQL> conn mind/mind123
 SQL> select * from employee; 






-----------------------------------------
<프로젝트 59> => 중요
프로젝트이름 : 오라클 연동하여 데이터 select 작업
클래스이름    : SelectTest
-------------------------------------------------------

 C:\oraclexe\app\oracle\product\10.2.0\server\jdbc\lib 경로=> ojdbc14.jar 존재

       ojdbc14.jar 압축파일을 풀면
            => oracle.jdbc.driver 폴더가 생긴다. driver 폴더안에 
                 => OracleDriver 클래스 파일이 존재한다.
------------------------------------------------------------------------




<프로젝트 60> => 중요
프로젝트이름 : employee 테이블에 데이터 삽입 작업
클래스이름    : DB_insert
----------------------------------------------------------

<프로젝트 61>
프로젝트이름: 스레드 실습
클래스이름   : TimerThread
-------------------------------  

<프로젝트 62>
프로젝트이름: 채팅 서버
클래스이름   : Server
---------------------------
<프로젝트 63>
프로젝트이름: 채팅 클라이언트
클래스이름   : Cilent
                    MainView
----------------------------------
블로그에서 소스 내려받기
  http://blog.naver.com/king5901
     => 자바 강의 자료
          => 채팅 클라이언트(소스)
---------------------------------------






<프로젝트 64> JAVA 최종 프로젝트 => 개별 프로젝트
프로젝트이름 : 고객관리 시스템
클래스이름    : ManageSystem
-----------------------------------
※ 프로젝트 발표자료(파워포인트 ppt) => 이번주 금요일(23일) 오후 발표

   제목 : 고객관리 시스템
             - 프로젝트 기획서
                   ▶ 프로젝트 소개, 제작 동기, 자료수집
             - 프로젝트 요구 분석서
                   ▶ 구조 분석, 개요 설계, 세부사항 설계 
             - 프로젝트 화면 설계
                   ▶ 입력기능, 출력기능 화면 구체적으로 작성 

             발표자: 홍길동
-------------------------------------
  ※ "찾기" 버튼 클릭시 검색 메소드 구현
     ========================
   int  type;    //전역변수 선언

          if(e.getActionCommand().equals("이름"))   type = 1;   //이름 검색
          else if(                                              ))    type=  7;   //직업 검색
          else if(                                              ))    type = 9;   //출신도 검색


   public void Search(){
          Vector v = new Vector();

          //순차 검색 알고리즘 적용
          for(int i=0; i<showTable.data.size(); i++){
               if(nameText.getText().equals(showTable.data.elementAt(i).get(type){
                     v.addElement(showTable.data.elementAt(i));
               }
          }
          showTable.datamodel.setDataVector(v, showTable.column_name);
------------------------------------------------------------------------------------------
  [참고]
   DefaultTableModel 클래스의 
    <메소드>
      void setDataVector(Vector dataVector, Vector columnIdentifiers)
             => 기능: 신규의 데이터벡터와 컬럼벡터를 합쳐서 새로 판을 짜는 메소드

             파라메터:
                          dataVector - the new data vector
                          columnIdentifiers - the names of the columns
------------------------------------------------------------------------------------- 
[참고]
  정렬 이벤트 처리
   
   public void itemStateChanged(ItemEvent e){
        if(e.getSource().equals(sno))              NoSort();         //'번호' 정렬
        else if(e.getSource().equals(sname))   StringSort(1);   //'이름' 정렬
        else if(e.getSource().equals(schul))     StringSort(7);   //'출신도' 정렬
        else if(e.getSource().equals(sjob))       StringSort(9);   //'직업' 정렬
   }
   //번호 정렬시
   public void NoSort(){
      int row = showTable.table.getRowCount();
      int col =  showTable.table.getColumnCount();

      String temp;
      String  arr[][] = new String[row][col];

      for(int i=0; i<row; i++){
         for(int j=0; j<col; j++){
             arr[i][j] = (String)showTable.table.getValueAt(i,j);
         }
      }
      //2차원 배열에 데이터를 선택정렬 알고리즘 적용
      . . . 
      . . .      
      for(int i=0; i<row; i++){
         for(int j=0; j<col; j++){
             showTable.table.setValueAt(arr[i][j], i, j);
         }
      }
   }
----------------------------------------




[프로젝트 65]
프로젝트이름: 고객관리 시스템 최종
클래스이름   : ManageSystem 
----------------------------------------
 블로그에서 
    자바강의자료
       => '고객관리 시스템 최종소스' 파일 내려받기
--------------------------------------------------------






프로젝트이름: 라벨(LABEL)을 반복문에서 활용하기
클래스이름   : BreakEx1
                   ContinueEx1 

 [실행결과]
 i 값:0, j값:0
 i 값:0, j값:1
 i 값:0, j값:2
----------------























[참고]
자바 프로젝트에서 => 오라클 Database에 연동을 하려면
                            반드시 다음 작업을 먼저 해야 한다

(1) C:\oraclexe\app\oracle\product\10.2.0\server\jdbc\lib 폴더에
    접근하면 => ojdbc14.jar 파일이 존재한다

(2) 이클립스에서
     프로젝트 이름을 선택하고
     => project 메뉴 - properties
                            - Java Build Path(왼쪽에) 클릭
                            - Libraries 탭(중앙에) 선택 후
                            - Add External JARs... 버튼 클릭한 후
                            => ojdbc14.jar 파일을 경로 찾아 [열기] - OK

(3) 그러면 프로젝트 디렉토리 창에
      => Referenced Libraries 폴더에
             => ojdbc14.jar 파일이 존재한다
----------------------------------------------------------------------------- 




[참고]
* select 작업은                         => executeQuery(sql) 메소드 호출
* insert, update, delete 작업은   => executeUpdate() 메소드 호출


















<프로젝트 51> => 아주 중요함
프로젝트이름 : 사원(employee) 테이블에 데이터 삽입(insert) 작업
클래스이름    : InsertTest
-------------------------------------------------------------------------
















<프로젝트 45> => 최종 프로젝트 => 파일 입출력(.txt 파일 저장)방식으로 개발
프로젝트이름 : 고객 관리 시스템
클래스이름    : 클래스 2개로 구현
                    (1) PersonalInfoInterface 클래스 
                    (2) PersonalInfoEvent 클래스     
------------------------------------------------------




















//외부 클래스
    MenuMain menuMain = new MenuMain();   //"메뉴" 배치 => 클래스
    West  west = new West();                        //"입력" 보더, "신상정보" 보더 배치
    ShowInfo  showInfo = new ShowInfo ();      //JTable 배치
    Button button = new Button();                  //"버튼"들 배치
    Operation operation = new Operation();     //Button의 내부 클래스
    PersonalInfoEvent personalInfoEvent = new PersonalInfoEvent();
 
     //외부 클래스 => 생성자
          add(menuMain.bar, BorderLayout.NORTH);
          add(west, BorderLayout.WEST);                       
          add(showInfo, BorderLayout.CENTER);
          add(button, BorderLayout.SOUTH);
    //------------------------------------------------------------
    //내부 클래스들 구현한다
    class MenuMain extends JPanel implements ActionListener{
           JMenuBar bar = new JMenuBar();
           . . . 
           . . .
    //---------------------------------------------------------------------
    West 내부 클래스에 2개의 내부 클래스 구현
                           (1) Input 클래스=> "입력" 보더=> BorderLayout.CENTER 배치 
                           (2) Output 클래스=> "신상정보" 보더=> BorderLayout.SOUTH 배치
----------------------------------------------------------------------------------------------------
먼저 데이터 입력 후 "추가" 버튼 클릭시 => 이벤트 처리

void DataSave(){
      Vector  tempData = new Vector();
      //입력 받은 데이터를 tempData에 추가
      tempData.add(. . . );
      . . . 
      . . .
      [참고]
      JComboBox에서 선택한 문자열 가져오는 방법
        인스턴스변수.getSelectedItem().toString()
      . . .
      showInfo.data.addElement(tempData);
      //테이블 모델 갱신
      showInfo.datamodel.fireTableDataChanged();
      operation.clearText();
}	
-----------------------------------------------------------
  class ShowInfo extends JPanel{
       Vector  data = new Vector();
       Vector data_name = new Vector();
       String table_name[] = {"번호","성명","핸드폰번호", . . . . . };
       //생성자
       ShowInfo(){
           for(int i=0; i<table_name.length; i++){
               data_name.add(table_name[i];
           }       
           DefaultTableModel datamodal = new DefaultTableModel(data, data_name);
           JTable table = new JTable(datamodal);
           JScrollPane scrollpane = new JScrollPane(table);

-----------------------------------------------------------------------
[중요]
int row = -1;   //row 변수는 전역변수로 선언

//JTable에서 특정셀을 마우스로 선택시 => 이벤트 처리
//------------------------------------------------------------
table.addMouseListener(new MouseAdapter() {
       public void mouseClicked(MouseEvent e) {
            row = table.getSelectedRow();
            operation.infoOutput();
       }
}};
----------------------------------------------------------------
javax.swing.table 패키지의
 * DefaultTableModel 클래스
      <중요 메소드>
         setDataVector(Vector dataVector, Vector columnIdentifiers)
            => 기능: 현재의 dataVector 인스턴스 변수를 새로운 행의
                         Vector인 dataVector에 옮겨놓는다

         fireTableDataChanged()
              => 기능: Notifies all listeners that all cell values in the table's rows may have                            changed. The number of rows may also have changed and the JTable                            should redraw the table from scratch. The structure of the table (as in                            the order of the columns) is assumed to be the same.
                    테이블의 행의 모든 셀치가 변경되고 있을 가능성이 있는 것을, 모든 청취자에게                     통지한다. 행수도 변경되고 있는 경우가 있어, JTable 는 테이블의 draw를 최초                       부터 다시 할 필요가 있다. 

                    테이블에 저장된 데이터가 변경되었고 그 내용을 화면에 반영해야할 
                    경우에는 TableModel에서 이 메소드를 호출하여 Table에 데이터이
                    바뀌었음을 알려주는 이벤트 발생시켜야 한다 
----------------------------------------------------------------------------------------------
javax.swing 패키지의
* JTabel 클래스
  [메소드] 
      int getSelectedRow()
        기능: Returns the index of the first selected row, -1 if no row is selected

      public Object getValueAt(int row, int column)
          기능: Returns the cell value at row and column. 

      changeSelection(int rowIndex, int columnIndex,   
                            boolean toggle, boolean extend)
       기능: toggle 와 extend 의 2 개의 플래그 상태에 의해, 테이블의 선택 모델을 갱신한다. 
              UI 가 받은 키보드 이벤트 또는 마우스 이벤트에 의해 행해진 선택 범위의 변경은 
              이 메소드에 의해 처리되어 서브 클래스가 동작을 오버라이드(override) 할 수 있게 된다.               UI 에는, 불연속인 선택 범위의 선두를 조작하는 경우 등, 이 메소드가 제공하는 것보다도               고도의 기능을 필요로 하는 것도 있어, 일부의 선택 범위의 변경에서는 그러한 UI 가 이 메              소드에 불러 들여지지 않은 것이 있다.  

       구현은 다음의 규칙을 사용합니다. 

       toggle:false,extend:false기존의 선택을 클리어 해, 새로운 셀이 확실히 선택되도록(듯이) 한다 
       toggle:false,extend:true기존의 선택을 엥커로부터 지정의 셀까지 확장해, 다른 모든 선택을 클        리어 한다 
       toggle:true,extend:false지정된 셀이 선택되고 있는 경우, 그 셀을 선택 해제한다. 선택되어 있        지 않은 경우, 그 셀을 선택한다 
       toggle:true,extend:true엥커의 선택 상태를, 그 엥커와 지정된 셀간의 모든 셀에 적용한다. 

       파라미터:
                   rowIndex - row 의 선택에 영향을 주는
                   columnIndex - column 의 선택에 영향을 주는
                   toggle - 상기 참조
                   extend - true 의 경우, 현재의 선택을 확장하는
 



 
     

























[참고]
아펙스(Apex)란?
  => Application Express의 약자로
      Oracle XE에서는 기본적으로 Apex를 제공한다
      웹으로 DB를 컨트롤 할 수 있는 웹 애플리케이션을 말한다
----------------------------------------------------------------------
[아펙스 port 번호 변경하기]
==================
SQL 명령줄 실행 창을 띄운 후

  SQL> conn /as sysdba
  SQL> exec dbms_xdb.setHTTPPort(9000);

웹 브라우저 뜨운 후
http://localhost:9000/apex
----------------------------------------------------------








<프로젝트 45>
프로젝트이름 : 타이머 레이블을 스레드로 구현
클래스이름    : ThreadTimerEx
-----------------------------------------------------


























* 자바 네트워크(소켓 프로그래밍)
======================
java.net 패키지의 ServerSocket 클래스
[생성자]
     ServerSocket(int port)

    (예)  서버측에서
    new  ServerSocket(8000)

   Socket  accept() 메소드 => 클라이언트의 요청을 받아들인 다음
                               Socket 객체를 생성해서 리턴하는 메소드
                               즉 서버소켓으로 연결요청이 들어오면 
                               연결을 맺고 클라이언트 소켓을 생성해서 리턴한다
-----------------------------------
java.net 패키지의 Socket 클래스
[생성자]
      Socket(InetAddress address, int port)

      (예) 클라이언측
        new Socket(서버ip주소, 8000)
--------------------------------------------------------     










 ※ Table 생성 후 데이터 입력을 효율적으로 하는 방법
===================
<오라클 SQL * Loader 실습>
===================
먼저 SQL 명령줄 실행창 띄우고
(1) SQL> conn testdb/testdb123
(2) 테이블 생성
SQL> create table dept_loader
        (deptno number(2),
         dname varchar2(14),
         loc varchar2(13));

(3) 제어 파일 생성 => 메모장 띄워놓고 작업
    [주의]  파일형식은 반드시 '모든파일'로 설정하고 
              아래 내용을 저장할 때 C:\ 드라이브 밑에 deptload.ctl 로 저장한다             
------------------------------------------    
LOAD DATA
INFILE *
INTO TABLE dept_loader insert
FIELDS terminated by ','
(deptno,dname,loc)
begindata
10,RESEARCH,SARATOGA
20,ACCOUNTING,CLEVELLAND
30,ART,SALEM                         =><주의> 엔터 치고 저장한다
------------------------------------



(4) c:\oraclexe\app\oracle\product\10.2.0\server\BIN 폴더에 
                                                                              => sqlldr.exe 파일 확인







시작 - 모든 프로그램 - 보조프로그램 - 명령프로프트 띄워놈

   > cd c:\
   단, 한줄로 입력한다.(줄 바꾸지 말고)
   c:\>c:\oraclexe\app\oracle\product\10.2.0\server\BIN\sqlldr  userid=testdb/testdb123 
                                                                   control=c:\deptload.ctl  direct=yes

(5) SQL 명령줄 실행창 띄우고
   SQL> select * from dept_loader;
-----------------------------------------------




 [문제3]
 SQL>create table member_second
         as select * from member;

 [문제4]
 SQL> create table member_third
          as select userid, username, passwd from member;

 SQL> create table member_forth
          as select * from member
          where 1 = 2;
 SQL> desc member_forth;
 SQL> select * from member_forth;

 [문제6]
 SQL> alter table member add(email varchar2(20));

 [문제7]
 SQL> alter table member modify address varchar2(50);

 [문제8]
 SQL> rename member_second to potential_member;
--------------------------------------------------------------
 [프로시져 생성]
 SQL> ed emp_10_select.sql

 create or replace procedure emp_10_select
 (no IN emp.deptno%TYPE,
  result OUT SYS_REFCURSOR)
  IS
  BEGIN
          OPEN result FOR
          select empno,ename,sal,deptno
          from emp
          where deptno = no;
  END;
  /
-------------------------------------------------



 SQL> conn system/system
 SQL> select tablespace_name, table_name
          from dba_tables
          where owner = 'TESTDB';










  



      





   




















































  





                        
  













       

       
              
 


  



        
 



   
 



          




           
                 

 



           
 

    





















